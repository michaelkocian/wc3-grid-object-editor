<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WC3 Object Editor</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<div class="hdr">
  <h1>WC3 Object Editor</h1>
  <button class="btn b-load" id="loadFileButton">📂 Load File</button>
  <span style="border-left:1px solid #0f3460;height:20px"></span>
  <button class="btn b-exp" id="exportBinaryButton">💾 Save File (Experimental)</button>
  <span style="border-left:1px solid #0f3460;height:20px"></span>
  <button class="btn b-imp" id="importJSONButton" title="Import from JSON (legacy)">Import JSON</button>
  <button class="btn b-imp" id="exportJSONButton" title="Export current tab as JSON (debug)">Export JSON</button>
</div>

<div class="tabs">
  <div class="tab active" data-t="items" id="tabItems">Items (not loaded)</div>
  <div class="tab" data-t="abilities" id="tabAbilities">Abilities (not loaded)</div>
  <div class="tab" data-t="units" id="tabUnits">Units (not loaded)</div>
  <div class="tab" data-t="buffs" id="tabBuffs">Buffs (not loaded)</div>
  <div class="tab" data-t="upgrades" id="tabUpgrades">Upgrades (not loaded)</div>
  <div class="tab" data-t="destructables" id="tabDestructables">Destructables (not loaded)</div>
  <div class="tab" data-t="doodads" id="tabDoodads">Doodads (not loaded)</div>
</div>

<div class="toolbar">
  <button class="btn b-add b-sm" id="addRowButton">+ Add Row (Experimental)</button>
  <input class="search" id="searchBox" placeholder="Search...">
  <div class="toggle-wrap">
    <label class="toggle" title="Show all columns">
      <input type="checkbox" id="showAllColsToggle">
      <span class="slider"></span>
    </label>
    <span class="toggle-label">All Columns</span>
  </div>
  <span class="stats" id="statsBar"></span>
</div>

<div id="itemsPane" class="tab-pane">
  <p style="color:#555;padding:20px">Load a .w3t file to begin editing items.</p>
</div>
<div id="abilitiesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3a file to begin editing abilities.</p>
</div>
<div id="unitsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3u file to begin editing units.</p>
</div>
<div id="buffsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3h file to begin editing buffs/effects.</p>
</div>
<div id="upgradesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3q file to begin editing upgrades.</p>
</div>
<div id="destructablesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3b file to begin editing destructables.</p>
</div>
<div id="doodadsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3d file to begin editing doodads.</p>
</div>

<!-- Add Row popup -->
<div class="ov hidden" id="popRow">
<div class="pop">
  <h3 id="popRowTitle">Add New Item</h3>
  <label>Base ID (4 chars)</label>
  <input id="arBase" maxlength="4" placeholder="ratf">
  <label>Table</label>
  <select id="arTable"><option value="custom">Custom</option><option value="original">Original</option></select>
  <div id="arLevelWrap">
    <label>Number of levels (abilities only)</label>
    <input id="arLevels" type="number" value="1" min="1" max="20">
  </div>
  <div class="pb">
    <button class="btn b-del b-sm" id="cancelButton">Cancel</button>
    <button class="btn b-exp b-sm" id="addButton">Add</button>
  </div>
</div></div>


<script type="module">
import { unitCodes } from './unitcodes.js';
import { META_TYPE_OPTIONS } from './dropdowns.js';
import { KNOWN } from './columns.js';

// Add event listeners using unique IDs
document.querySelector('#cancelButton').addEventListener('click', () => closePopup('popRow'));
document.querySelector('#addButton').addEventListener('click', confirmAddRow);
document.querySelector('#loadFileButton').addEventListener('click', loadFile);
document.querySelector('#exportBinaryButton').addEventListener('click', exportBinary);
document.querySelector('#importJSONButton').addEventListener('click', loadJSONFile);
document.querySelector('#exportJSONButton').addEventListener('click', exportJSON);
document.querySelector('#tabItems').addEventListener('click', () => switchTab('items'));
document.querySelector('#tabAbilities').addEventListener('click', () => switchTab('abilities'));
document.querySelector('#tabUnits').addEventListener('click', () => switchTab('units'));
document.querySelector('#tabBuffs').addEventListener('click', () => switchTab('buffs'));
document.querySelector('#tabUpgrades').addEventListener('click', () => switchTab('upgrades'));
document.querySelector('#tabDestructables').addEventListener('click', () => switchTab('destructables'));
document.querySelector('#tabDoodads').addEventListener('click', () => switchTab('doodads'));
document.querySelector('#addRowButton').addEventListener('click', showAddRow);
document.querySelector('#searchBox').addEventListener('input', filterRows);
document.querySelector('#showAllColsToggle').addEventListener('change', toggleAllColumns);



function fieldName(id) { return KNOWN[id]?.n || id; }

// ================================================================
// TYPE CONSTANTS
// ================================================================
const TYPE_INT    = 0;
const TYPE_REAL   = 1;
const TYPE_UNREAL = 2;
const TYPE_STRING = 3;
const TYPE_NAMES  = { 0:'int', 1:'real', 2:'unreal', 3:'string' };
const TYPE_IDS    = { int:0, real:1, unreal:2, string:3 };

// Object types that carry level + column per modification
const TYPES_WITH_LEVELS = new Set(['w3a','w3d','w3q']);

// ================================================================
// META-TYPE RESOLUTION
//
// The binary format stores only int/real/unreal/string.
// KNOWN[fieldId].t carries a richer metadata type (e.g. "bool",
// "icon", "unitRace", "techList").  These helpers bridge the two.
// ================================================================

/** Return the metadata type for a field id, e.g. "bool", "icon". Falls back to wire type. */
function getMetaType(fieldId) {
  return KNOWN[fieldId]?.t || null;
}

/** Map a metadata type to the binary wire-type name used by the format. */
function getWireType(metaType) {
  if (!metaType) return 'string';
  if (metaType === 'bool' || metaType === 'int') return 'int';
  if (metaType === 'real')   return 'real';
  if (metaType === 'unreal') return 'unreal';
  return 'string';  // icon, model, unitRace, techList, etc.
}


// Extension info
const EXT_INFO = {
  w3t: { label:'Items',          hasLevels:false },
  w3a: { label:'Abilities',      hasLevels:true  },
  w3u: { label:'Units',          hasLevels:false },
  w3b: { label:'Destructables',  hasLevels:false },
  w3h: { label:'Buffs',          hasLevels:false },
  w3d: { label:'Doodads',        hasLevels:true  },
  w3q: { label:'Upgrades',       hasLevels:true  },
};

// ================================================================
// ALL STANDARD COLUMNS PER GRID TYPE  (Name first, then alphabetical)
// These define which columns appear in the "All Columns" view.
// Ability-specific data fields (uppercase IDs) are discovered dynamically.
// ================================================================
const GRID_COLS = {
  items: ['unam','iabi','iarm','iclb','iclg','iclr','icid','icla','ides','idro','idrp','ifil','igol','ihtp','iicd','iico','ilev','ilum','ilvo','imor','ipaw','iper','ipow','ipri','iprn','isca','isel','issc','isst','isto','istr','iusa','iuse','ubpx','ubpy','ufoo','uhot','isit','ureq','urqa','utip','utub','bdns','urq1','urq2','urq3','urq4','urq5','urq6','urq7','urq8'],
  abilities: ['anam','aaea','aani','aare','aart','abpx','abpy','abuf','aca1','acac','acap','acas','acat','achd','acdn','adur','aeat','aeff','aefl','aefs','ahdu','aher','ahky','aite','alev','alig','alsk','amac','amat','amcs','amho','amsp','ansf','aord','aorf','aoro','aoru','apri','arac','aran','arar','areq','aret','arhk','arlv','arpx','arpy','arqa','arut','asat','aspt','ata0','ata1','ata2','ata3','ata4','ata5','atac','atar','atat','atp1','auar','aub1','aubx','auby','auhk','ausk','aut1','auu1'],
  units: ['unam','ua1b','ua1c','ua1d','ua1f','ua1g','ua1h','ua1m','ua1p','ua1q','ua1r','ua1s','ua1t','ua1w','ua1z','ua2b','ua2c','ua2d','ua2f','ua2g','ua2h','ua2m','ua2p','ua2q','ua2r','ua2s','ua2t','ua2w','ua2z','uaap','uabi','uabs','uabr','uabt','uacq','uaen','uagi','uagp','ualp','uamn','uani','uarm','uawt','ubba','ubdg','ubdi','uble','ubld','ubpx','ubpy','ubpr','ubs1','ubs2','ubsi','ubui','ucam','ucar','ucbs','uclb','uclg','uclr','ucol','ucpt','ucs1','ucs2','ucua','ucun','ucut','udaa','udea','udef','udep','udl1','udl2','udp1','udp2','udro','udtm','udty','udu1','udu2','udup','uept','uerd','ufle','ufma','ufoo','ufor','ufrd','ugol','ugor','uhab','uhas','uhd1','uhd2','uhhb','uhhd','uhhm','uhom','uhos','uhot','uhpm','uhpr','uhrt','uico','uimz','uine','uinp','uint','uisz','ulba','ulbd','ulbs','ulev','ulfi','ulfo','ulos','ulpx','ulpy','ulpz','ulsz','ulum','ulur','uma1','uma2','umas','upor','umdl','umh1','umh2','umis','umki','umpi','umpm','umpr','umsl','umvf','umvh','umvr','umvs','umvt','umxp','umxr','unsf','uocc','uori','upap','upar','upat','upaw','upoi','upra','upri','upro','uprw','upru','upgr','uqd1','uqd2','urac','urb1','urb2','ureq','ures','urev','urpg','urpo','urpp','urpr','urqa','urtm','urun','ursl','urva','usca','uscb','usd1','usd2','usei','useu','usew','ushb','ushh','ushr','ushu','ushw','ushx','ushy','usid','usin','usle','uslz','usma','usit','usnd','uspa','uspe','usr1','usr2','usrg','ussc','ussi','usst','ustp','ustr','utaa','utar','utc1','utc2','utcc','utco','util','utip','utpr','utra','utss','utub','utyp','uub1','uubs','uuch','uupt','uver','uwal','uwu1','uwu2', 'unbr', 'unbs'],
  buffs: ['fnam','fart','feat','feff','fefl','fefs','feft','flig','fmac','fmat','fmho','fmsp','fnsf','frac','fsat','fspd','fspt','fta0','fta1','fta2','fta3','fta4','fta5','ftac','ftat','ftip','fube'],
  upgrades: ['gnam','gar1','gba1','gba2','gba3','gba4','gbpx','gbpy','gcls','gco1','gco2','gco3','gco4','gef1','gef2','gef3','gef4','gglb','gglm','ghk1','ginh','glmb','glmm','glob','glvl','gmo1','gmo2','gmo3','gmo4','gnsf','grac','greq','grqc','gtib','gtim','gtp1','gub1'],
  destructables: ['bnam','barm','bbut','bcat','bclh','bcpd','bcpr','bdsn','bfil','bflh','bflo','bfra','bfvi','bfxr','bgpm','bgsc','bgse','bhps','blit','bmap','bmar','bmas','bmis','bmmb','bmmg','bmmr','boch','bonc','bonw','bptd','bptx','brad','breg','brel','bret','bsel','bshd','bsmm','bsuf','btar','btil','btsp','btxf','btxi','buch','bumm','busr','bvar','bvcb','bvcg','bvcr','bwal'],
  doodads: ['dnam','danf','dcat','dcpr','ddes','dfil','dflt','dfxr','dimc','dmap','dmar','dmas','dmis','dmmb','dmmg','dmmr','donc','donw','dptx','dsel','dshd','dshf','dsmm','dsnd','dtil','dtsp','duch','dumc','dusr','dvar','dvb1','dvg1','dvis','dvr1','dwlk'],
};

const CAT_LABELS = {text:'Text',abilities:'Abilities',art:'Art',combat:'Combat',data:'Data',editor:'Editor',hero:'Hero',movement:'Movement',pathing:'Pathing',sound:'Sound',stats:'Stats',techtree:'Techtree'};
const CAT_ORDER_LIST = ['text','abilities','art','combat','data','editor','hero','movement','pathing','sound','stats','techtree'];

// ================================================================
// BINARY READER  (browser ArrayBuffer)
//
// Reference: WC3MapTranslator W3Buffer / ObjectsTranslator.ts
// All multi-byte values are little-endian.
// Strings are null-terminated UTF-8.
// IDs are 4 raw ASCII bytes (or 0x00000000 for "none").
// ================================================================
class BinaryReader {
  constructor(arrayBuffer) {
    this.buf = new DataView(arrayBuffer);
    this.u8  = new Uint8Array(arrayBuffer);
    this.pos = 0;
    this.len = arrayBuffer.byteLength;
  }
  hasMore()    { return this.pos < this.len; }
  readInt32()  { const v = this.buf.getInt32(this.pos, true);  this.pos += 4; return v; }
  readUInt32() { const v = this.buf.getUint32(this.pos, true); this.pos += 4; return v; }
  readFloat32(){
    const v = this.buf.getFloat32(this.pos, true);
    this.pos += 4;
    return v;
  }
  readId() {
    const a = this.u8[this.pos], b = this.u8[this.pos+1],
          c = this.u8[this.pos+2], d = this.u8[this.pos+3];
    this.pos += 4;
    if (a === 0 && b === 0 && c === 0 && d === 0) return '\0\0\0\0';
    return String.fromCharCode(a, b, c, d);
  }
  readString() {
    let end = this.pos;
    while (end < this.len && this.u8[end] !== 0) end++;
    const bytes = this.u8.subarray(this.pos, end);
    this.pos = end + 1;
    return new TextDecoder('utf-8').decode(bytes);
  }
}

// ================================================================
// BINARY WRITER  (browser ArrayBuffer)
//
// Builds a list of Uint8Array chunks, then concatenates into a Blob.
// ================================================================
class BinaryWriter {
  constructor() { this.parts = []; }
  writeInt32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setInt32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeUInt32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setUint32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeFloat32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setFloat32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeId(s) {
    const b = new Uint8Array(4);
    if (s && s !== '\0\0\0\0') {
      for (let i = 0; i < 4 && i < s.length; i++) b[i] = s.charCodeAt(i) & 0xFF;
    }
    this.parts.push(b);
  }
  writeString(s) {
    this.parts.push(new TextEncoder().encode(s));
    this.parts.push(new Uint8Array([0]));
  }
  toBlob() {
    return new Blob(this.parts, { type: 'application/octet-stream' });
  }
  toUint8Array() {
    let total = 0;
    for (const p of this.parts) total += p.byteLength;
    const out = new Uint8Array(total);
    let off = 0;
    for (const p of this.parts) { out.set(p, off); off += p.byteLength; }
    return out;
  }
}

// ================================================================
// PARSE BINARY -> editor state
//
// Binary layout per spec (https://github.com/stijnherfst/HiveWE/wiki/war3map(skin).w3*-Modifications):
//   uint32  format_version  (1, 2, or 3)
//   -- table (repeated 1 or 2 times, must check EOF) --
//   uint32  object_count
//   for each object:
//     char[4]  original_id
//     char[4]  modified_id   (0x00000000 for original table entries)
//     if format_version >= 3:
//       uint32  sets_count
//     else: sets_count = 1
//     for each set:
//       if format_version >= 3:
//         uint32  set_flag
//       uint32  modifications_count
//       for each modification:
//         char[4]  modification_id
//         uint32   variable_type (0=int, 1=real, 2=unreal, 3=string)
//         if optional_ints:
//           uint32 level_variation
//           uint32 data_pointer
//         value (int32 | float32 | float32 | c_string)
//         if format_version > 0:
//           char[4]  end_token
// ================================================================
function parseBinaryBuffer(arrayBuffer, ext) {
  const r = new BinaryReader(arrayBuffer);
  const version = r.readUInt32();
  // Per spec: .w3a and .w3q always have optional_ints;
  // .w3d (doodads) has optional_ints only when format_version > 0
  const hasLevels = (ext === 'w3a' || ext === 'w3q') || (ext === 'w3d' && version > 0);

  const objects = { original: [], custom: [] };

  for (const tableKey of ['original', 'custom']) {
    // Spec: second table may not exist — check for EOF
    if (!r.hasMore()) break;

    const count = r.readUInt32();
    for (let i = 0; i < count; i++) {
      const baseId   = r.readId();
      const customId = r.readId();

      // sets_count only exists in version >= 3
      const setsCount = (version >= 3) ? r.readUInt32() : 1;

      const obj = {
        base_id: baseId,
        custom_id: (customId !== '\0\0\0\0') ? customId : null,
        fields: [],
        _endTag: null
      };

      // Iterate over all sets (typically 1)
      for (let s = 0; s < setsCount; s++) {
        // set_flag only exists in version >= 3
        if (version >= 3) {
          r.readUInt32(); // set_flag (0 = default/all asset modes)
        }

        const modCount = r.readUInt32();

        for (let m = 0; m < modCount; m++) {
          const fieldId   = r.readId();
          const valueType = r.readUInt32();

          let level = 0, column = 0;
          if (hasLevels) {
            level  = r.readUInt32();
            column = r.readUInt32();
          }

          let value;
          if (valueType === TYPE_INT)         value = r.readInt32();
          else if (valueType === TYPE_REAL)   value = r.readFloat32();
          else if (valueType === TYPE_UNREAL) value = r.readFloat32();
          else if (valueType === TYPE_STRING) value = r.readString();
          else                                value = r.readInt32();    // fallback

          // end_token only exists when format_version > 0
          let endTag = null;
          if (version > 0) {
            endTag = r.readId();
          }
          if (m === 0 && obj._endTag === null) obj._endTag = endTag;

          const field = { id: fieldId, type: TYPE_NAMES[valueType] || String(valueType) };
          if (hasLevels) { field.level = level; field.column = column; }
          field.value = value;
          field.endTag = endTag; // per-field end tag for mixed-endtag objects
          obj.fields.push(field);
        }
      }
      objects[tableKey].push(obj);
    }
  }
  return { version, hasLevels, ext, objects };
}

// ================================================================
// BUILD BINARY from current editor state
//
// Reconstructs the end-tag per the WC3 spec:
//   original table entries -> end tag = base ID
//   custom   table entries -> end tag = 0x00000000
// ================================================================
function buildBinaryFromState(type) {
  const st = S[type]; if (!st) return null;
  syncDOM(type);

  const hasLevels = st.meta._hasLevels;
  const w = new BinaryWriter();
  w.writeUInt32(st.meta.version || 3);

  // Rebuild object lists from rows
  const tables = { original: [], custom: [] };

  if (!hasLevels) {
    for (const row of st.rows) {
      const obj = {
        base_id: row.bid, custom_id: row.cid || null,
        tbl: row.tbl, _endTag: row._endTag, fields: []
      };
      const ordered = orderedFieldIds(row, st.cols);
      for (const fid of ordered) {
        const cell = row.v[fid];
        if (!cell) continue;
        const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
        obj.fields.push({ id: fid, type: ftype, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
      }
      tables[row.tbl].push(obj);
    }
  } else {
    // Group rows by gid
    const groups = new Map();
    const groupOrder = [];
    for (const row of st.rows) {
      if (!groups.has(row.gid)) { groups.set(row.gid, []); groupOrder.push(row.gid); }
      groups.get(row.gid).push(row);
    }
    for (const gid of groupOrder) {
      const gRows = groups.get(gid);
      const first = gRows[0];
      const obj = {
        base_id: first.bid, custom_id: first.cid || null,
        tbl: first.tbl, _endTag: first._endTag, fields: []
      };

      const rowByLevel = {};
      for (const row of gRows) rowByLevel[row.lvl] = row;

      if (first._gfo && first._gfo.length > 0) {
        // Preserve original cross-level field order
        const used = new Set();
        for (const { id: fid, lvl } of first._gfo) {
          const key = fid + '@' + lvl;
          if (used.has(key)) continue;
          used.add(key);
          // Main-row-only fields were relocated to level 0 during ingestion;
          // try the original level first, then fall back to level 0
          let row = rowByLevel[lvl];
          let cell = row ? row.v[fid] : null;
          if (!cell && rowByLevel[0]) {
            row = rowByLevel[0];
            cell = row.v[fid];
          }
          if (!row || !cell) continue;
          const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
          // Write the original level, not the row's current level
          const writeLevel = cell._origLevel != null ? cell._origLevel : lvl;
          obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                            value: coerceVal(cell.val, ftype), endTag: cell.endTag });
        }
        // Append any NEW fields not in original order
        for (const row of gRows) {
          for (const c of st.cols) {
            const key = c.id + '@' + (row.v[c.id]?._origLevel != null ? row.v[c.id]._origLevel : row.lvl);
            if (used.has(key)) continue;
            const cell = row.v[c.id]; if (!cell) continue;
            used.add(key);
            const ftype = cell.type || c.type;
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: c.id, type: ftype, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
          }
        }
      } else {
        for (const row of gRows) {
          const ordered = orderedFieldIds(row, st.cols);
          for (const fid of ordered) {
            const cell = row.v[fid]; if (!cell) continue;
            const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: fid, type: ftype, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
          }
        }
      }
      tables[first.tbl].push(obj);
    }
  }

  const writeVersion = st.meta.version || 3;

  // Write both tables to binary
  for (const tableKey of ['original', 'custom']) {
    const objs = tables[tableKey];
    w.writeUInt32(objs.length);

    for (const obj of objs) {
      w.writeId(obj.base_id);
      w.writeId(obj.custom_id || '\0\0\0\0');

      // sets_count and set_flag only in version >= 3
      if (writeVersion >= 3) {
        w.writeUInt32(1); // sets_count: always 1
        w.writeUInt32(0); // set_flag: 0 = default (all asset modes)
      }

      w.writeUInt32(obj.fields.length);

      for (const field of obj.fields) {
        const vtype = TYPE_IDS[field.type] ?? 0;
        w.writeId(field.id);
        w.writeUInt32(vtype);

        if (hasLevels) {
          w.writeUInt32(field.level ?? 0);
          w.writeUInt32(field.column ?? 0);
        }

        if (vtype === TYPE_INT)          w.writeInt32(Number(field.value) | 0);
        else if (vtype === TYPE_REAL)    w.writeFloat32(Number(field.value));
        else if (vtype === TYPE_UNREAL)  w.writeFloat32(Number(field.value));
        else if (vtype === TYPE_STRING)  w.writeString(String(field.value));
        else                             w.writeInt32(Number(field.value) | 0);

        // end_token only when format_version > 0
        if (writeVersion > 0) {
          // Per spec: use 0 (safe default) or the object's custom/base ID
          const endTag = field.endTag != null ? field.endTag
            : (obj._endTag != null ? obj._endTag
              : '\0\0\0\0');
          w.writeId(endTag);
        }
      }
    }
  }

  return w;
}

// ================================================================
// EDITOR STATE
// ================================================================
// S[type] = { meta, rows[], cols[] }
//   meta  = { _format, _type, _hasLevels, version, _fileName }
//   row   = { gid, tbl, bid, cid, lvl, v:{fieldId:{val,type,col?}}, _fo:[], _gfo? }
//   col   = { id, name, type }
const S = { items: null, abilities: null, units: null, buffs: null, upgrades: null, destructables: null, doodads: null };
let activeTab = 'items';

/** Map file extension to editor tab name. */
const EXT_TO_TYPE = {
  w3t: 'items', w3a: 'abilities', w3u: 'units',
  w3h: 'buffs', w3q: 'upgrades', w3b: 'destructables', w3d: 'doodads'
};
function extToType(ext) { return EXT_TO_TYPE[ext] || null; }

/** Field ID that stores the level/variation count for each leveled type. */
const LEVEL_COUNT_FIELD = {
  abilities: 'alev',
  upgrades: 'glvl',
  doodads: 'dvar'
};

/** Fields that can ONLY be edited in the main (head) row, not in sub-rows. */
const MAIN_ROW_ONLY = {
  abilities: new Set([
    'aani','aaea','abpx','abpy','arpx','arpy','aubx','auby',
    'acat','acap','aca1','acac','aeat','aart','arar','auar',
    'alig','amac','amat','amho','amsp','asat','aspt','unsf',
    'atat','ata0','ata1','ata2','ata3','ata4','ata5','atac',
    'ausk','aefs','aefl','aher','aite','alsk','alev','apri',
    'arac','arlv','achd','areq','arqa','ansf','arhk','ahky',
    'auhk','anam','aoro','aorf','aoru','aord','aret','arut'
  ])
};

/** For doodads, only these fields are editable in sub-rows (variations); all others are main-row-only. */
const SUB_ROW_EDITABLE = {
  doodads: new Set(['dvr1','dvg1','dvb1']),
  upgrades: new Set(['gar1', 'greq', 'grqc', 'gnsf', 'ghk1', 'gnam', 'gtp1', 'gub1']),
};

/** Check whether a field should be read-only in sub-rows. */
function isMainRowOnly(type, fieldId) {
  if (MAIN_ROW_ONLY[type]) return MAIN_ROW_ONLY[type].has(fieldId);
  if (SUB_ROW_EDITABLE[type]) return !SUB_ROW_EDITABLE[type].has(fieldId);
  return false;
}

/**
 * Columns that should ALWAYS appear in sub-rows when showAllColumns is ON,
 * even if no row has data for them.  Keyed by editor type.
 * Add entries here as needed for other types / fields.
 */
const SUBROW_ALWAYS_VISIBLE = {
  doodads: ['dvr1', 'dvg1', 'dvb1'],   // Tinting colors
  upgrades: ['gar1', 'greq', 'grqc', 'gnsf', 'ghk1', 'gnam', 'gtp1', 'gub1'],
  abilities: ['atp1', 'aub1', 'amcs', 'atar', 'adur']
};

/** Tracks which category IDs are collapsed, per type. */
const collapsedCategories = {};

function getCollapsedCats(type) {
  if (!collapsedCategories[type]) collapsedCategories[type] = new Set();
  return collapsedCategories[type];
}

function toggleCategory(type, catId) {
  const c = getCollapsedCats(type);
  if (c.has(catId)) c.delete(catId); else c.add(catId);
  const st = S[type]; if (!st) return;
  syncDOM(type);
  const scrollPos = saveScroll(type);
  renderTable(type);
  restoreScroll(type, scrollPos);
}

/**
 * Groups an array of column objects by KNOWN[id].c categories.
 * Fields without a category: uppercase-start or contains digit → 'data', else 'other'.
 * Returns: Array<{ cat:{id,label}, cols:col[] }>
 */
function getCategoryGroups(type, cols) {
  const orderMap = {};
  CAT_ORDER_LIST.forEach((c, i) => orderMap[c] = i);
  const grouped = new Map();
  for (const col of cols) {
    let cat = KNOWN[col.id]?.c;
    if (!cat) cat = (/^[A-Z]/.test(col.id) || /\d/.test(col.id)) ? 'data' : 'other';
    if (!grouped.has(cat)) grouped.set(cat, []);
    grouped.get(cat).push(col);
  }
  const result = [];
  for (const [cat, catCols] of grouped) {
    const label = CAT_LABELS[cat] || cat.charAt(0).toUpperCase() + cat.slice(1);
    result.push({ cat: { id: cat, label }, cols: catCols });
  }
  result.sort((a, b) => (orderMap[a.cat.id] ?? 999) - (orderMap[b.cat.id] ?? 999));
  return result;
}

/**
 * Renders the category header <tr> above the column header row.
 * Collapsed categories appear as a single narrow stub column.
 */
function renderCatHeaderRow(type, catGroups, collapsed) {
  let h = '<tr class="cat-head-row">';
  h += '<th colspan="5" class="cat-spacer"></th>';
  for (const g of catGroups) {
    const isC = collapsed.has(g.cat.id);
    const safe = g.cat.id.replace(/'/g,'\\\"'), lbl = esc(g.cat.label);
    const colCount = g.cols.length; // Calculate the number of columns
    if (isC) {
      h += '<th class="cat-head cat-collapsed" onclick="toggleCategory(\'' + esc(type) + '\',\'' + safe + '\')" title="Expand ' + lbl + ' (' + colCount + ' columns)"><span class="cat-toggle">+</span> ' + lbl + ' (' + colCount + ')</th>';
    } else {
      h += '<th class="cat-head cat-expanded" colspan="' + colCount + '" onclick="toggleCategory(\'' + esc(type) + '\',\'' + safe + '\')" title="Collapse ' + lbl + ' (' + colCount + ' columns)">' + lbl + ' (' + colCount + ')</th>';
    }
  }
  h += '</tr>';
  return h;
}

/**
 * Renders data cells for a row using category groups.
 * Collapsed categories insert a single stub <td> instead of their columns.
 * Sub-rows (level tables) must NOT use this – use renderCells() directly.
 */
function renderCatCells(ri, r, catGroups, collapsed, subRowType, ownerType, gid) {
  let h = '';
  for (const g of catGroups) {
    if (collapsed.has(g.cat.id)) {
      h += '<td class="cat-stub"></td>';
    } else {
      h += renderCells(ri, r, g.cols, subRowType, ownerType, gid);
    }
  }
  return h;
}

/** Global toggle: show all known columns vs only columns with data */
let showAllColumns = false;

/**
 * Get display columns for rendering.
 * When showAllColumns is OFF  -> only columns that appear in data (st.cols).
 * When showAllColumns is ON   -> all columns from GRID_COLS for the
 *   type, plus any extra data-only columns not in the list.
 * Columns are sorted alphabetically with the Name field first.
 */
function getDisplayCols(type) {
  const st = S[type]; if (!st) return [];
  if (!showAllColumns) return st.cols;

  const gridCols = GRID_COLS[type] || [];
  const existingMap = new Map(st.cols.map(c => [c.id, c]));

  // Collect all field IDs: grid columns + any data-only fields
  const allIds = new Set([...gridCols]);
  for (const c of st.cols) allIds.add(c.id);

  // Build column list
  const result = [];
  const seen = new Set();
  for (const id of allIds) {
    if (seen.has(id)) continue;
    seen.add(id);
    if (existingMap.has(id)) {
      result.push(existingMap.get(id));
    } else {
      const known = KNOWN[id];
      if (known) {
        result.push({ id, name: known.n, type: getWireType(known.t) });
      }
    }
  }

  // Sort alphabetically, Name field first
  sortColumnsAlpha(result);
  return result;
}

/** Toggle all-columns visibility and re-render the active tab. */
function toggleAllColumns() {
  showAllColumns = document.getElementById('showAllColsToggle').checked;
  const type = activeTab;
  const st = S[type]; if (!st) return;
  syncDOM(type);
  const scrollPos = saveScroll(type);
  renderTable(type);
  restoreScroll(type, scrollPos);
}

// ================================================================
// UNIFIED LOAD FILE  (auto-detect format from extension)
// ================================================================
function loadFile() {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.multiple = true;
  inp.accept = '.w3t,.w3a,.w3u,.w3b,.w3h,.w3d,.w3q,.json';
  inp.onchange = e => {
    const files = [...e.target.files]; if (!files.length) return;
    let lastType = null;
    let pending = files.length;
    function done(type) { lastType = type; if (--pending === 0 && lastType) switchTab(lastType); }

    for (const f of files) {
      const ext = f.name.split('.').pop().toLowerCase();

      if (ext === 'json') {
        const rd = new FileReader();
        rd.onload = ev => {
          try {
            const json = JSON.parse(ev.target.result);
            const fileExt = json._type || 'w3t';
            const hasLevels = json._hasLevels || TYPES_WITH_LEVELS.has(fileExt);
            const parsed = { version: json.version || 3, hasLevels, ext: fileExt,
              objects: { original: json.original || json.original_items || [], custom: json.custom || json.custom_items || [] } };
            const detectedType = extToType(fileExt) || 'items';
            ingestParsed(detectedType, parsed, f.name);
            done(detectedType);
          } catch (err) { alert('JSON error (' + f.name + '): ' + err.message); done(null); }
        };
        rd.readAsText(f);
        continue;
      }

      const info = EXT_INFO[ext];
      if (!info) { alert('Unsupported file type: .' + ext); done(null); continue; }
      const detectedType = extToType(ext) || 'items';

      const rd = new FileReader();
      rd.onload = ev => {
        try {
          const parsed = parseBinaryBuffer(ev.target.result, ext);
          ingestParsed(detectedType, parsed, f.name);
          done(detectedType);
        } catch (err) {
          alert('Binary parse error (' + f.name + '): ' + err.message + '\n' + err.stack);
          done(null);
        }
      };
      rd.readAsArrayBuffer(f);
    }
  };
  inp.click();
}

// ================================================================
// LOAD BINARY FILE  (browser ArrayBuffer)
// ================================================================
function loadBinaryFile(type) {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = '.w3t,.w3a,.w3u,.w3b,.w3h,.w3d,.w3q';
  inp.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const ext = f.name.split('.').pop().toLowerCase();
    const info = EXT_INFO[ext];
    if (!info) { alert('Unsupported file type: .' + ext); return; }

    // Auto-detect tab from extension
    const detectedType = extToType(ext) || 'items';

    const rd = new FileReader();
    rd.onload = ev => {
      try {
        const parsed = parseBinaryBuffer(ev.target.result, ext);
        ingestParsed(detectedType, parsed, f.name);
        switchTab(detectedType);
      } catch (err) {
        alert('Binary parse error: ' + err.message + '\n' + err.stack);
      }
    };
    rd.readAsArrayBuffer(f);
  };
  inp.click();
}

// ================================================================
// LOAD JSON FILE  (legacy import, for backwards compatibility)
// ================================================================
function loadJSONFile() {
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.json';
  inp.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = ev => {
      try {
        const json = JSON.parse(ev.target.result);
        const ext = json._type || 'w3t';
        const hasLevels = json._hasLevels || TYPES_WITH_LEVELS.has(ext);
        const parsed = {
          version: json.version || 3,
          hasLevels,
          ext,
          objects: {
            original: json.original || json.original_items || [],
            custom:   json.custom   || json.custom_items   || [],
          }
        };
        const detectedType = extToType(ext) || 'items';
        ingestParsed(detectedType, parsed, f.name);
        switchTab(detectedType);
      } catch (err) { alert('JSON error: ' + err.message); }
    };
    rd.readAsText(f);
  };
  inp.click();
}

// ================================================================
// INGEST parsed binary/json data into editor state
// ================================================================
function ingestParsed(type, parsed, fileName) {
  const { version, hasLevels, ext, objects } = parsed;

  const meta = {
    _format: 'war3map.' + ext,
    _type: ext,
    _hasLevels: hasLevels,
    version: version,
    _fileName: fileName,
  };

  const fieldsMap = new Map(); // fieldId -> { name, type }
  const unsortedRows = [];
  let gid = 0;

  for (const tbl of ['original', 'custom']) {
    const objs = objects[tbl] || [];

    for (const obj of objs) {
      if (!hasLevels) {
        // Simple objects: one row per object
        const row = makeRow(gid++, tbl, obj);
        for (const f of obj.fields) {
          row.v[f.id] = { val: f.value, type: f.type, endTag: f.endTag };
          row._fo.push(f.id);
          registerField(fieldsMap, f.id, f.type);
        }
        unsortedRows.push(row);
      } else {
        // Leveled objects: one head row (level 0) + sub-rows for levels 1..N
        // N = max(level_count_field_value, max_level_in_data)
        const gfo = obj.fields.map(f => ({ id: f.id, lvl: f.level ?? 0 }));
        const detectedType = type;
        const lcfId = LEVEL_COUNT_FIELD[type] || null;

        // Determine level count from the field (alev/glvl/dvar)
        let levelCountFromField = 0;
        if (lcfId) {
          for (const f of obj.fields) {
            if (f.id === lcfId) {
              levelCountFromField = parseInt(f.value) || 0;
              break;
            }
          }
        }
        // Find the max level referenced by any data field
        let maxLevelInData = 0;
        for (const f of obj.fields) {
          const lvl = f.level ?? 0;
          if (lvl > maxLevelInData) maxLevelInData = lvl;
        }
        // The number of sub-rows = max of the two
        const numLevels = Math.max(levelCountFromField, maxLevelInData);

        // Distribute fields into per-level buckets
        const byLevel = new Map();
        byLevel.set(0, []); // head row always exists
        for (let l = 1; l <= numLevels; l++) {
          byLevel.set(l, []); // pre-create all level rows 1..N
        }

        for (const f of obj.fields) {
          const origLvl = f.level ?? 0;
          registerField(fieldsMap, f.id, f.type);

          // Main-row-only fields → head row (level 0)
          if (isMainRowOnly(detectedType, f.id)) {
            byLevel.get(0).push({ ...f, _origLevel: origLvl });
          } else {
            // Level-specific fields stay at their exact original level
            let lvl = origLvl;
            if (lvl < 0) lvl = 0;
            if (!byLevel.has(lvl)) byLevel.set(lvl, []);
            byLevel.get(lvl).push({ ...f, _origLevel: origLvl });
          }
        }

        const levels = [...byLevel.keys()].sort((a, b) => a - b);
        const g = gid++;
        for (let li = 0; li < levels.length; li++) {
          const lvl = levels[li];
          const row = makeRow(g, tbl, obj, lvl);
          if (li === 0) row._gfo = gfo; // store original field order on first row
          for (const f of (byLevel.get(lvl) || [])) {
            row.v[f.id] = { val: f.value, type: f.type, col: f.column, endTag: f.endTag,
                            _origLevel: f._origLevel };
            row._fo.push(f.id);
          }
          unsortedRows.push(row);
        }
      }
    }
  }

  // Sort rows so entries with the same base_id are grouped together,
  // mixing original and custom. Within a base_id group: original first,
  // then custom sorted by custom_id.
  // Collect groups by gid first to keep sub-rows together with their head.
  const groupMap = new Map(); // gid -> { bid, cid, tbl, rows[] }
  const groupOrder = [];
  for (const row of unsortedRows) {
    if (!groupMap.has(row.gid)) {
      groupMap.set(row.gid, { bid: row.bid, cid: row.cid, tbl: row.tbl, rows: [] });
      groupOrder.push(row.gid);
    }
    groupMap.get(row.gid).rows.push(row);
  }

  // Sort group keys by base_id, then original-before-custom, then custom_id
  groupOrder.sort((a, b) => {
    const ga = groupMap.get(a), gb = groupMap.get(b);
    if (ga.bid < gb.bid) return -1;
    if (ga.bid > gb.bid) return 1;
    // Same base_id: original before custom
    if (ga.tbl !== gb.tbl) return ga.tbl === 'original' ? -1 : 1;
    // Same table: sort by custom_id
    const ca = ga.cid || '', cb = gb.cid || '';
    return ca.localeCompare(cb);
  });

  // Re-assign sequential gids and flatten
  const rows = [];
  let newGid = 0;
  for (const oldGid of groupOrder) {
    const g = groupMap.get(oldGid);
    const assignedGid = newGid++;
    for (const row of g.rows) {
      row.gid = assignedGid;
      rows.push(row);
    }
  }

  // Build ordered column list (alphabetical, Name first)
  const colIds = sortFieldIds([...fieldsMap.keys()]);
  const cols = colIds.map(id => ({ id, name: fieldsMap.get(id).name, type: fieldsMap.get(id).type }));

  S[type] = { meta, rows, cols };
  renderTable(type);
  updateTabLabel(type);
}

function makeRow(gid, tbl, obj, lvl) {
  return {
    gid, tbl,
    bid: obj.base_id,
    cid: obj.custom_id || '',
    _endTag: obj._endTag || null,
    lvl: lvl ?? null,
    v: {},
    _fo: []
  };
}

function registerField(map, id, type) {
  if (!map.has(id)) map.set(id, { name: fieldName(id), type });
}

/** Name field IDs (always sorted first). */
const NAME_FIELDS = new Set(['unam','anam','dnam','bnam','fnam','gnam']);

/** Sort field IDs by display name with Name fields first. */
function sortFieldIds(ids) {
  return ids.sort((a, b) => {
    const na = NAME_FIELDS.has(a), nb = NAME_FIELDS.has(b);
    if (na !== nb) return na ? -1 : 1;
    return fieldName(a).localeCompare(fieldName(b));
  });
}

/** Sort column objects by display name with Name fields first. */
function sortColumnsAlpha(cols) {
  cols.sort((a, b) => {
    const na = NAME_FIELDS.has(a.id), nb = NAME_FIELDS.has(b.id);
    if (na !== nb) return na ? -1 : 1;
    return a.name.localeCompare(b.name);
  });
}

// ================================================================
// RENDER TABLE
// ================================================================
function renderTable(type) {
  const st = S[type]; if (!st) return;
  const { meta, rows } = st;
  const cols = getDisplayCols(type);
  const hl = meta._hasLevels;
  const lcf = LEVEL_COUNT_FIELD[type] || null;
  const pane = document.getElementById(type + 'Pane');

  let h = '<div class="tw"><table>';

  if (!hl) {
    // ---- Non-leveled: flat header with category row + column row ----
    const catGroups = getCategoryGroups(type, cols);
    const collapsed = getCollapsedCats(type);
    h += '<thead>';
    h += renderCatHeaderRow(type, catGroups, collapsed);
    h += '<tr>';
    h += '<th style="width:40px" data-default-w="40">#<span class="col-resize" data-ci="0"></span></th>';
    h += '<th style="width:52px" data-default-w="52"><span class="col-resize" data-ci="1"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Table<span class="col-resize" data-ci="2"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Base ID<span class="col-resize" data-ci="3"></span></th>';
    h += '<th style="width:70px" data-default-w="70">Custom ID<span class="col-resize" data-ci="4"></span></th>';
    let ci = 5;
    for (const g of catGroups) {
      if (collapsed.has(g.cat.id)) {
        h += '<th class="cat-stub"><span class="col-resize" data-ci="' + ci + '"></span></th>';
        ci++;
      } else {
        for (const c of g.cols) {
          h += '<th style="width:160px" data-default-w="160" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + ' (' + c.type + ')</span><span class="col-resize" data-ci="' + ci + '"></span></th>';
          ci++;
        }
      }
    }
    h += '</tr></thead><tbody>';

    // ---- Non-leveled: simple flat rows ----
    let prevGid = -1, groupAlt = false;
    for (let ri = 0; ri < rows.length; ri++) {
      const r = rows[ri];
      if (r.gid !== prevGid) { groupAlt = !groupAlt; prevGid = r.gid; }
      const rc = r.tbl === 'original' ? 'r0' : 'r1';
      const ga = groupAlt ? 'ga' : '';
      const searchText = esc([r.bid, r.cid, ...Object.keys(r.v).map(k => r.v[k].val)].join(' ').toLowerCase());

      h += '<tr class="' + rc + ' ' + ga + '" data-s="' + searchText + '">';
      h += '<td style="color:#555;text-align:right;padding-right:4px">' + (ri + 1) + '</td>';
      h += '<td class="del-c"><button class="btn b-del b-sm" onclick="removeRow(\'' + type + '\',' + ri + ')" title="Remove row">&times;</button><button class="btn b-add b-sm" onclick="duplicateRow(\'' + type + '\',' + ri + ')" title="Duplicate row" style="margin-left:2px">&#x2398;</button></td>';
      h += '<td style="font-size:11px;color:#999">' + r.tbl + '</td>';
      h += '<td class="idc">' + esc(r.bid) + '</td>';
      h += '<td class="idc">' + esc(r.cid || '\u2014') + '</td>';
      h += renderCatCells(ri, r, catGroups, collapsed, null, type, r.gid);
      h += '</tr>';
    }
  } else {
    // ---- Leveled: split columns into main-row and level-specific ----
    const mainCols = [];
    const levelCols = [];
    for (const c of cols) {
      if (isMainRowOnly(type, c.id) || (lcf && c.id === lcf)) {
        mainCols.push(c);
      } else {
        levelCols.push(c);
      }
    }

    // Outer table header: category row + column row (main-row columns only)
    const mainCatGroups = getCategoryGroups(type, mainCols);
    const collapsed = getCollapsedCats(type);
    h += '<thead>';
    h += renderCatHeaderRow(type, mainCatGroups, collapsed);
    h += '<tr>';
    h += '<th style="width:40px" data-default-w="40">#<span class="col-resize" data-ci="0"></span></th>';
    h += '<th style="width:52px" data-default-w="52"><span class="col-resize" data-ci="1"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Table<span class="col-resize" data-ci="2"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Base ID<span class="col-resize" data-ci="3"></span></th>';
    h += '<th style="width:70px" data-default-w="70">Custom ID<span class="col-resize" data-ci="4"></span></th>';
    let ci = 5;
    for (const g of mainCatGroups) {
      if (collapsed.has(g.cat.id)) {
        h += '<th class="cat-stub"><span class="col-resize" data-ci="' + ci + '"></span></th>';
        ci++;
      } else {
        for (const c of g.cols) {
          h += '<th style="width:160px" data-default-w="160" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + ' (' + c.type + ')</span><span class="col-resize" data-ci="' + ci + '"></span></th>';
          ci++;
        }
      }
    }
    h += '</tr></thead><tbody>';

    // totalOuterCols: 5 fixed + 1 stub per collapsed cat + N cols per expanded cat
    let totalOuterCols = 5;
    for (const g of mainCatGroups) totalOuterCols += collapsed.has(g.cat.id) ? 1 : g.cols.length;

    // Build groups in order
    const groups = [];
    const groupMap = new Map();
    for (let ri = 0; ri < rows.length; ri++) {
      const r = rows[ri];
      if (!groupMap.has(r.gid)) {
        const g = { gid: r.gid, indices: [] };
        groupMap.set(r.gid, g);
        groups.push(g);
      }
      groupMap.get(r.gid).indices.push(ri);
    }

    // Pre-compute merged level columns per base_id:
    // Groups with the same bid share the same set of level columns.
    const bidGroupMap = new Map(); // bid -> [group indices into groups[]]
    for (let gi = 0; gi < groups.length; gi++) {
      const grp = groups[gi];
      const bid = rows[grp.indices[0]].bid;
      if (!bidGroupMap.has(bid)) bidGroupMap.set(bid, []);
      bidGroupMap.get(bid).push(gi);
    }
    // For each bid, collect the union of level columns that have data in any
    // sub-row of any group with that bid.
    const bidLevelCols = new Map(); // bid -> levelCol[]
    for (const [bid, gIndices] of bidGroupMap) {
      const usedColIds = new Set();
      for (const gi of gIndices) {
        const grp = groups[gi];
        const indices = grp.indices;
        for (const ri of indices) {
          if ((rows[ri].lvl ?? 0) === 0) continue; // skip head rows
          for (const c of levelCols) {
            const cell = rows[ri].v[c.id];
            if (cell && cell.val !== '' && cell.val !== null && cell.val !== undefined) usedColIds.add(c.id);
          }
        }
      }
      bidLevelCols.set(bid, levelCols.filter(c => usedColIds.has(c.id)));
    }

    // When showAllColumns is ON, add always-visible sub-row columns for this type
    if (showAllColumns && SUBROW_ALWAYS_VISIBLE[type]) {
      const alwaysIds = new Set(SUBROW_ALWAYS_VISIBLE[type]);
      for (const [bid, curCols] of bidLevelCols) {
        const existingIds = new Set(curCols.map(c => c.id));
        const extraCols = levelCols.filter(c => alwaysIds.has(c.id) && !existingIds.has(c.id));
        if (extraCols.length > 0) {
          const merged = [...curCols, ...extraCols];
          // Sort by display name, Name fields first
          sortColumnsAlpha(merged);
          bidLevelCols.set(bid, merged);
        }
      }
    }

    let groupAlt = false;
    for (const grp of groups) {
      groupAlt = !groupAlt;
      const indices = grp.indices;
      // Sort: level 0 first, then ascending
      indices.sort((a, b) => (rows[a].lvl ?? 0) - (rows[b].lvl ?? 0));

      const headIdx = indices[0];
      const headRow = rows[headIdx];
      const subIndices = indices.filter(ri => (rows[ri].lvl ?? 0) > 0);
      const rc = headRow.tbl === 'original' ? 'r0' : 'r1';
      const ga = groupAlt ? 'ga' : '';

      // Collect search text from entire group
      const allGroupText = indices.map(ri => {
        const r = rows[ri];
        return [r.bid, r.cid, ...Object.keys(r.v).map(k => r.v[k].val)].join(' ').toLowerCase();
      }).join(' ');
      const searchText = esc(allGroupText);

      // ---- Head row: main-row columns only ----
      h += '<tr class="' + rc + ' ' + ga + ' grp-head" data-s="' + searchText + '" data-gid="' + headRow.gid + '">';
      h += '<td style="color:#555;text-align:right;padding-right:4px">' + (headIdx + 1) + '</td>';
      h += '<td class="del-c"><button class="btn b-del b-sm" onclick="removeGroup(\'' + type + '\',' + headRow.gid + ')" title="Remove object">&times;</button><button class="btn b-add b-sm" onclick="duplicateRow(\'' + type + '\',' + headIdx + ')" title="Duplicate object" style="margin-left:2px">&#x2398;</button></td>';
      h += '<td style="font-size:11px;color:#999">' + headRow.tbl + '</td>';
      h += '<td class="idc">' + esc(headRow.bid) + '</td>';
      h += '<td class="idc">' + esc(headRow.cid || '\u2014') + '</td>';
      h += renderCatCells(headIdx, headRow, mainCatGroups, collapsed, null, type, headRow.gid);
      h += '</tr>';

      // ---- Level sub-table: use merged columns for this bid ----
      const mergedLevelCols = bidLevelCols.get(headRow.bid) || [];
      if (mergedLevelCols.length > 0 && subIndices.length > 0) {
        h += '<tr class="' + rc + ' ' + ga + ' sub-table-row" data-gid="' + headRow.gid + '" data-s="' + searchText + '">';
        h += '<td colspan="' + totalOuterCols + '">';
        h += '<table class="level-table">';
        h += '<thead><tr>';
        h += '<th style="width:30px" data-default-w="30">Lvl</th>';
        let lci = 1;
        for (const c of mergedLevelCols) {
          h += '<th style="width:140px" data-default-w="140" data-code="' + esc(c.id) + '" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + ' (' + c.type + ')</span><span class="col-resize" data-ci="' + lci + '"></span></th>';
          lci++;
        }
        h += '</tr></thead><tbody>';

        for (const si of subIndices) {
          const sr = rows[si];
          const src = sr.tbl === 'original' ? 'r0' : 'r1';
          h += '<tr class="' + src + '">';
          h += '<td class="sr-lvl">' + (sr.lvl ?? '') + '</td>';
          h += renderCells(si, sr, mergedLevelCols, null, type, sr.gid);
          h += '</tr>';
        }

        h += '</tbody></table></td></tr>';
      }
    }
  }

  h += '</tbody></table></div>';
  pane.innerHTML = h;
  st._renderedAllCols = showAllColumns;
  updateStats(type);
}

/** Render the data cells for a row (shared between main and sub-rows).
 *  subRowType: if truthy, fields marked main-row-only are rendered read-only.
 *  ownerType/gid: used for context. */
function renderCells(ri, r, cols, subRowType, ownerType, gid) {
  let h = '';
  const lcf = ownerType ? (LEVEL_COUNT_FIELD[ownerType] || null) : null;
  for (const c of cols) {
    // Level-count field: render as editable number that also triggers changeLevelCount
    if (lcf && c.id === lcf && !subRowType) {
      const cell = r.v[c.id];
      const storedVal = cell ? (cell.val ?? '') : '';
      h += '<td style="text-align:center"><input type="number" min="0" value="' + storedVal + '" data-r="' + ri + '" data-f="' + c.id + '" style="width:48px;background:#252550;color:#e0e0e0;border:1px solid #0f3460;border-radius:2px;font:11px Consolas,monospace;text-align:center;padding:1px" onchange="changeLevelCount(\'' + ownerType + '\',' + gid + ',this.value)" title="Number of levels/variations (source value)"></td>';
      continue;
    }

    const cell = r.v[c.id];
    let val = cell ? cell.val ?? '' : '';
    if (val !== '' && (c.type === 'real' || c.type === 'unreal')) val = parseFloat(Number(val).toFixed(3));

    // Read-only cell for sub-rows where this field is main-row-only
    if (subRowType && isMainRowOnly(subRowType, c.id)) {
      h += '<td class="ro-cell">' + esc(String(val)) + '</td>';
      continue;
    }

    const mt = getMetaType(c.id);
    const opts = mt ? META_TYPE_OPTIONS[mt] : null;
    if (opts) {
      h += '<td><select data-r="' + ri + '" data-f="' + c.id + '" data-mt="' + (mt||'') + '">';
      h += '<option value=""' + (val === '' ? ' selected' : '') + '></option>';
      for (const o of opts) {
        const sel = (String(val) === o.value) ? ' selected' : '';
        h += '<option value="' + escA(o.value) + '"' + sel + '>' + esc(o.label) + '</option>';
      }
      h += '</select></td>';
    } else {
      h += '<td><input value="' + escA(String(val)) + '" data-r="' + ri + '" data-f="' + c.id + '" data-mt="' + (mt||'') + '"></td>';
    }
  }
  return h;
}

function updateTabLabel(type) {
  const st = S[type]; if (!st) return;
  const label = {items:'Items', abilities:'Abilities', units:'Units', buffs:'Buffs', upgrades:'Upgrades', destructables:'Destructables', doodads:'Doodads'}[type] || type;
  const n = st.rows.length;
  const fname = st.meta._fileName ? (' \u2014 ' + st.meta._fileName) : '';
  document.querySelector('.tab[data-t="' + type + '"]').textContent = label + ' (' + n + ' rows)' + fname;
}

function updateStats(type) {
  const st = S[type];
  if (!st) { document.getElementById('statsBar').textContent = ''; return; }
  const origObjs = new Set(st.rows.filter(r => r.tbl === 'original').map(r => r.gid)).size;
  const custObjs = new Set(st.rows.filter(r => r.tbl === 'custom').map(r => r.gid)).size;
  const filledCells = st.rows.reduce((s, r) => s + Object.keys(r.v).length, 0);
  document.getElementById('statsBar').textContent =
    origObjs + ' original + ' + custObjs + ' custom objects  |  ' +
    st.cols.length + ' columns  |  ' + filledCells + ' values  |  v' +
    st.meta.version + '  |  .' + st.meta._type;
}

// ================================================================
// SYNC DOM -> STATE
// ================================================================
function syncDOM(type) {
  const st = S[type]; if (!st) return;
  const pane = document.getElementById(type + 'Pane');
  // Gather both <input> and <select> elements with data-r
  const elems = pane.querySelectorAll('input[data-r], select[data-r]');
  for (const el of elems) {
    const ri = parseInt(el.dataset.r);
    const fid = el.dataset.f;
    const row = st.rows[ri];
    if (!row) continue;
    const raw = el.value;

    if (row.v[fid]) {
      // Existing cell - update value
      const cell = row.v[fid];
      if (cell.type === 'int') { const n = parseInt(raw, 10); cell.val = isNaN(n) ? 0 : n; }
      else if (cell.type === 'real' || cell.type === 'unreal') { const n = parseFloat(raw); cell.val = isNaN(n) ? 0 : n; }
      else cell.val = raw;
    } else if (raw !== '') {
      // New cell - create only if user typed/selected something
      const col = st.cols.find(c => c.id === fid);
      const ctype = col ? col.type : 'string';
      const cell = { val: raw, type: ctype };
      if (ctype === 'int') { const n = parseInt(raw, 10); cell.val = isNaN(n) ? 0 : n; }
      else if (ctype === 'real' || ctype === 'unreal') { const n = parseFloat(raw); cell.val = isNaN(n) ? 0 : n; }
      if (st.meta._hasLevels) cell.col = 0;
      row.v[fid] = cell;
    }
  }
}

// ================================================================
// EXPORT BINARY  (.w3t / .w3a / etc.)
// ================================================================
function exportBinary(type) {
  // If no type specified, use active tab
  if (!type) type = activeTab;
  
  // Use active tab if specified type has no data
  if (!S[type] && S[activeTab]) type = activeTab;
  const st = S[type];
  if (!st) { alert('No ' + type + ' data loaded.'); return; }

  const writer = buildBinaryFromState(type);
  if (!writer) { alert('No ' + type + ' data loaded.'); return; }

  const ext = st.meta._type || 'w3t';
  const blob = writer.toBlob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = st.meta._fileName || ('war3map.' + ext);
  a.click();
  URL.revokeObjectURL(url);
}

// ================================================================
// EXPORT JSON  (debug / legacy)
// ================================================================
function exportJSON() {
  const type = activeTab;
  const st = S[type];
  if (!st) { alert('No ' + type + ' data loaded.'); return; }
  syncDOM(type);

  const hasLevels = st.meta._hasLevels;
  const json = {
    _format: st.meta._format,
    _type: st.meta._type,
    _hasLevels: hasLevels,
    version: st.meta.version,
    original: [],
    custom: [],
  };

  if (!hasLevels) {
    for (const row of st.rows) {
      const obj = { base_id: row.bid, custom_id: row.cid || null, fields: [] };
      const ordered = orderedFieldIds(row, st.cols);
      for (const fid of ordered) {
        const cell = row.v[fid]; if (!cell) continue;
        const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
        obj.fields.push({ id: fid, type: ftype, value: coerceVal(cell.val, ftype) });
      }
      json[row.tbl].push(obj);
    }
  } else {
    const groups = new Map();
    const groupOrder = [];
    for (const row of st.rows) {
      if (!groups.has(row.gid)) { groups.set(row.gid, []); groupOrder.push(row.gid); }
      groups.get(row.gid).push(row);
    }
    for (const gid of groupOrder) {
      const gRows = groups.get(gid);
      const first = gRows[0];
      const obj = { base_id: first.bid, custom_id: first.cid || null, fields: [] };
      const rowByLevel = {};
      for (const row of gRows) rowByLevel[row.lvl] = row;

      if (first._gfo && first._gfo.length > 0) {
        const used = new Set();
        for (const { id: fid, lvl } of first._gfo) {
          const key = fid + '@' + lvl;
          if (used.has(key)) continue;
          used.add(key);
          let row = rowByLevel[lvl];
          let cell = row ? row.v[fid] : null;
          if (!cell && rowByLevel[0]) {
            row = rowByLevel[0];
            cell = row.v[fid];
          }
          if (!row || !cell) continue;
          const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
          const writeLevel = cell._origLevel != null ? cell._origLevel : lvl;
          obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                            value: coerceVal(cell.val, ftype) });
        }
        for (const row of gRows) {
          for (const c of st.cols) {
            const key = c.id + '@' + (row.v[c.id]?._origLevel != null ? row.v[c.id]._origLevel : row.lvl);
            if (used.has(key)) continue;
            const cell = row.v[c.id]; if (!cell) continue;
            used.add(key);
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: c.id, type: cell.type || c.type, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, cell.type || c.type) });
          }
        }
      } else {
        for (const row of gRows) {
          const ordered = orderedFieldIds(row, st.cols);
          for (const fid of ordered) {
            const cell = row.v[fid]; if (!cell) continue;
            const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                              value: coerceVal(cell.val, ftype) });
          }
        }
      }
      json[first.tbl].push(obj);
    }
  }

  const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (type || 'data') + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

// Ordered field IDs: original order first, then any new fields
function orderedFieldIds(row, cols) {
  const seen = new Set(row._fo || []);
  const result = [...(row._fo || [])];
  for (const c of cols) {
    if (!seen.has(c.id) && row.v[c.id]) { result.push(c.id); }
  }
  return result;
}

function coerceVal(v, type) {
  if (type === 'int') { const n = parseInt(v, 10); return isNaN(n) ? 0 : n; }
  if (type === 'real' || type === 'unreal') { const n = parseFloat(v); return isNaN(n) ? 0 : n; }
  return String(v);
}

// ================================================================
// AUTO-GENERATE NEXT UNUSED CUSTOM ID
// Items: I + 3 chars, Abilities: A + 3 chars, Units: U + 3 chars (0-9a-z)
// ================================================================
const ID_CHARS = '0123456789abcdefghijklmnopqrstuvwxyz';

function nextUnusedId(type) {
  const prefix = {abilities:'A', units:'U', buffs:'B', upgrades:'R', destructables:'D', doodads:'O', items:'I'}[type] || 'X';
  // Collect all existing custom IDs across all tabs
  const used = new Set();
  for (const key of ['items', 'abilities', 'units', 'buffs', 'upgrades', 'destructables', 'doodads']) {
    if (!S[key]) continue;
    for (const row of S[key].rows) {
      if (row.cid) used.add(row.cid);
    }
  }
  // Iterate through all 36^3 = 46656 combinations
  for (let i = 0; i < 36 * 36 * 36; i++) {
    const c0 = ID_CHARS[Math.floor(i / (36 * 36)) % 36];
    const c1 = ID_CHARS[Math.floor(i / 36) % 36];
    const c2 = ID_CHARS[i % 36];
    const id = prefix + c0 + c1 + c2;
    if (!used.has(id)) return id;
  }
  alert('No unused IDs remaining!');
  return null;
}

// ================================================================
// TAB SWITCHING
// ================================================================
function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.t === tab));
  for (const k of ['items','abilities','units','buffs','upgrades','destructables','doodads']) {
    document.getElementById(k + 'Pane').classList.toggle('hidden', tab !== k);
  }
  // Re-render if showAllColumns state changed since this tab was last rendered
  const st = S[tab];
  if (st && st._renderedAllCols !== showAllColumns) {
    syncDOM(tab);
    const scrollPos = saveScroll(tab);
    renderTable(tab);
    restoreScroll(tab, scrollPos);
  }
  updateStats(tab);
}

// ================================================================
// SEARCH / FILTER
// ================================================================
function filterRows() {
  const q = document.getElementById('searchBox').value.toLowerCase().trim();
  const pane = document.getElementById(activeTab + 'Pane');
  const trs = pane.querySelectorAll('tbody tr');
  if (!q) { trs.forEach(tr => tr.style.display = ''); return; }

  const st = S[activeTab];
  if (st && st.meta._hasLevels) {
    // For leveled types, show entire group if any row matches
    const matchedGids = new Set();
    trs.forEach(tr => {
      if ((tr.dataset.s || '').includes(q)) matchedGids.add(tr.dataset.gid);
    });
    trs.forEach(tr => {
      tr.style.display = matchedGids.has(tr.dataset.gid) ? '' : 'none';
    });
  } else {
    trs.forEach(tr => {
      tr.style.display = (tr.dataset.s || '').includes(q) ? '' : 'none';
    });
  }
}

// ================================================================
// ADD ROW
// ================================================================
function showAddRow() {
  if (!S[activeTab]) { alert('Load data first.'); return; }
  document.getElementById('popRowTitle').textContent = 'Add New ' + ({items:'Item', abilities:'Ability', units:'Unit', buffs:'Buff', upgrades:'Upgrade', destructables:'Destructable', doodads:'Doodad'}[activeTab] || 'Object');
  document.getElementById('arLevelWrap').style.display = (S[activeTab]?.meta._hasLevels) ? '' : 'none';
  document.getElementById('arBase').value = '';
  document.getElementById('arLevels').value = '1';
  document.getElementById('popRow').classList.remove('hidden');
  document.getElementById('arBase').focus();
}

function confirmAddRow() {
  const type = activeTab;
  const st = S[type]; if (!st) return;
  syncDOM(type);

  const bid = document.getElementById('arBase').value.trim();
  const tbl = document.getElementById('arTable').value;
  if (!bid || bid.length !== 4) { alert('Base ID must be exactly 4 characters.'); return; }

  let cid = '';
  if (tbl === 'custom') {
    cid = nextUnusedId(type);
    if (!cid) return;
  }

  const gid = st.rows.length > 0 ? Math.max(...st.rows.map(r => r.gid)) + 1 : 0;

  if (!st.meta._hasLevels) {
    st.rows.push({ gid, tbl, bid, cid, lvl: null, v: {}, _fo: [] });
  } else {
    const nLevels = parseInt(document.getElementById('arLevels').value) || 1;
    for (let l = 0; l <= nLevels; l++) {
      st.rows.push({ gid, tbl, bid, cid, lvl: l, v: {}, _fo: [] });
    }
  }

  renderTable(type);
  updateTabLabel(type);
  closePopup('popRow');
}

function removeRow(type, idx) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  if (!confirm('Remove this row?')) return;
  const scrollPos = saveScroll(type);
  st.rows.splice(idx, 1);
  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

/** Remove all rows belonging to a group (leveled objects). */
function removeGroup(type, gid) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  if (!confirm('Remove this object and all its levels?')) return;
  const scrollPos = saveScroll(type);
  st.rows = st.rows.filter(r => r.gid !== gid);
  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

/** Change the number of sub-rows (levels/variations) for a group. */
function changeLevelCount(type, gid, rawVal) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  const scrollPos = saveScroll(type);

  let desired = parseInt(rawVal, 10);
  if (isNaN(desired) || desired < 0) desired = 0;

  // Find all rows in this group, sorted by level
  const groupRows = st.rows.filter(r => r.gid === gid);
  if (groupRows.length === 0) return;
  groupRows.sort((a, b) => (a.lvl ?? 0) - (b.lvl ?? 0));

  const head = groupRows[0]; // level-0 row
  const currentSubs = groupRows.filter(r => r.lvl > 0);
  const currentCount = currentSubs.length;

  if (desired === currentCount) return;

  // Also update the level-count field in the head row's data
  const lcf = LEVEL_COUNT_FIELD[type];
  if (lcf) {
    if (head.v[lcf]) head.v[lcf].val = desired;
    else head.v[lcf] = { val: desired, type: 'int', col: 0 };
  }

  if (desired > currentCount) {
    // Add new sub-rows after the last row of this group
    const lastIdx = st.rows.lastIndexOf(groupRows[groupRows.length - 1]);
    const startLvl = currentCount + 1;
    const newRows = [];
    for (let l = startLvl; l <= desired; l++) {
      newRows.push({
        gid: head.gid, tbl: head.tbl,
        bid: head.bid, cid: head.cid,
        _endTag: head._endTag,
        lvl: l, v: {}, _fo: []
      });
    }
    st.rows.splice(lastIdx + 1, 0, ...newRows);
  } else {
    // Remove excess sub-rows (highest levels first)
    const toRemove = new Set();
    for (let i = currentSubs.length - 1; i >= desired; i--) {
      toRemove.add(currentSubs[i]);
    }
    st.rows = st.rows.filter(r => !toRemove.has(r));
  }

  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

function duplicateRow(type, idx) {
  const st = S[type]; if (!st) return;
  syncDOM(type);

  const scrollPos = saveScroll(type);
  const src = st.rows[idx];
  const newCid = nextUnusedId(type);
  if (!newCid) return;

  const newGid = st.rows.length > 0 ? Math.max(...st.rows.map(r => r.gid)) + 1 : 0;

  if (!st.meta._hasLevels) {
    // Simple: duplicate single row
    const newRow = {
      gid: newGid, tbl: 'custom',
      bid: src.bid, cid: newCid,
      lvl: src.lvl,
      v: JSON.parse(JSON.stringify(src.v)),
      _fo: [...(src._fo || [])]
    };
    st.rows.splice(idx + 1, 0, newRow);
  } else {
    // Leveled: duplicate all rows in the same group
    const srcGid = src.gid;
    const groupRows = st.rows.filter(r => r.gid === srcGid);
    // Find insertion point: after last row of this group
    let lastIdx = idx;
    for (let i = 0; i < st.rows.length; i++) {
      if (st.rows[i].gid === srcGid) lastIdx = i;
    }
    const newRows = groupRows.map((r, i) => {
      const nr = {
        gid: newGid, tbl: 'custom',
        bid: r.bid, cid: newCid,
        lvl: r.lvl,
        v: JSON.parse(JSON.stringify(r.v)),
        _fo: [...(r._fo || [])]
      };
      if (i === 0 && r._gfo) nr._gfo = JSON.parse(JSON.stringify(r._gfo));
      return nr;
    });
    st.rows.splice(lastIdx + 1, 0, ...newRows);
  }

  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

// ================================================================
// SCROLL SAVE / RESTORE
// ================================================================
function saveScroll(type) {
  const pane = document.getElementById(type + 'Pane');
  const tw = pane ? pane.querySelector('.tw') : null;
  return tw ? { top: tw.scrollTop, left: tw.scrollLeft } : { top: 0, left: 0 };
}
function restoreScroll(type, pos) {
  if (!pos) return;
  const pane = document.getElementById(type + 'Pane');
  const tw = pane ? pane.querySelector('.tw') : null;
  if (tw) { tw.scrollTop = pos.top; tw.scrollLeft = pos.left; }
}

// ================================================================
// POPUP / ESCAPE HELPERS
// ================================================================
function closePopup(id) { document.getElementById(id).classList.add('hidden'); }
function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function escA(s) { return String(s).replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ================================================================
// ENTER KEY: move cursor to the cell directly below
// ================================================================
document.addEventListener('keydown', function(e) {
  if (e.key !== 'Enter') return;
  const el = e.target;
  if (!el.matches || !el.matches('td input[data-r], td select[data-r]')) return;
  e.preventDefault();
  const td = el.closest('td');
  const tr = td.closest('tr');
  const table = tr.closest('table');
  if (!td || !tr || !table) return;
  const ci = Array.from(tr.children).indexOf(td);
  // Walk forward through sibling rows to find the next visible row
  let next = tr.nextElementSibling;
  while (next && next.offsetParent === null) next = next.nextElementSibling;
  if (!next) return;
  const nextTd = next.children[ci];
  if (!nextTd) return;
  const inp = nextTd.querySelector('input, select');
  if (inp) { inp.focus(); inp.select && inp.select(); }
});

// ================================================================
// DOUBLE-CLICK COLUMN HEADER TO AUTO-FIT WIDTH (toggle: auto-fit / default)
// ================================================================
function setColWidth(th, w, cells) {
  th.style.width = w + 'px';
  th.style.minWidth = w + 'px';
  th.style.maxWidth = w + 'px';
  for (const td of cells) {
    td.style.width = w + 'px';
    td.style.minWidth = w + 'px';
    td.style.maxWidth = w + 'px';
  }
}
function getDirectCells(table, ci) {
  return Array.from(table.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (ci + 1) + ')'));
}
document.addEventListener('dblclick', function(e) {
  const th = e.target.closest('th');
  if (!th || e.target.closest('.col-resize')) return;
  const table = th.closest('table');
  if (!table) return;
  const ci = Array.from(th.parentElement.children).indexOf(th);
  if (ci < 0) return;
  const isLevelTable = table.classList.contains('level-table');
  const isExpanded = th.dataset.expanded === '1';

  // Collect all related ths and cells (for level-table sync)
  let allThs = [th];
  let allCellSets = [{ th: th, cells: getDirectCells(table, ci) }];
  if (isLevelTable && th.dataset.code) {
    const code = th.dataset.code;
    document.querySelectorAll('.level-table th[data-code="' + code + '"]').forEach(function(otherTh) {
      if (otherTh === th) return;
      allThs.push(otherTh);
      const otherTable = otherTh.closest('table');
      const otherCi = Array.from(otherTh.parentElement.children).indexOf(otherTh);
      allCellSets.push({ th: otherTh, cells: getDirectCells(otherTable, otherCi) });
    });
  }

  if (isExpanded) {
    // ---- Restore default width ----
    for (const s of allCellSets) {
      const defW = parseInt(s.th.dataset.defaultW) || 140;
      setColWidth(s.th, defW, s.cells);
      s.th.dataset.expanded = '0';
    }
  } else {
    // ---- Auto-fit: measure widest content across all related columns ----
    let maxW = 30;
    const measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;font:12px Consolas,monospace;padding:2px 6px';
    document.body.appendChild(measurer);
    for (const s of allCellSets) {
      // measure header text
      measurer.textContent = s.th.textContent;
      maxW = Math.max(maxW, measurer.offsetWidth + 12);
      for (const td of s.cells) {
        const inp = td.querySelector('input,select');
        const text = inp ? inp.value : td.textContent;
        measurer.textContent = text;
        maxW = Math.max(maxW, measurer.offsetWidth + 12);
      }
    }
    document.body.removeChild(measurer);
    for (const s of allCellSets) {
      setColWidth(s.th, maxW, s.cells);
      s.th.dataset.expanded = '1';
    }
  }
});

// ================================================================
// COLUMN RESIZE
// ================================================================
(function() {
  let resizing = false, startX = 0, startW = 0, th = null, colIdx = -1;
  function applyColWidth(newW) {
    th.style.width = newW + 'px';
    th.style.minWidth = newW + 'px';
    th.style.maxWidth = newW + 'px';
    const table = th.closest('table');
    if (!table) return;
    // Use :scope > to avoid matching cells in nested sub-tables
    const tds = table.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (colIdx + 1) + ')');
    for (const td of tds) {
      td.style.width = newW + 'px';
      td.style.minWidth = newW + 'px';
      td.style.maxWidth = newW + 'px';
    }
    // For level-table columns, sync all level-tables with the same column code
    if (table.classList.contains('level-table') && th.dataset.code) {
      const code = th.dataset.code;
      document.querySelectorAll('.level-table th[data-code="' + code + '"]').forEach(function(otherTh) {
        if (otherTh === th) return;
        otherTh.style.width = newW + 'px';
        otherTh.style.minWidth = newW + 'px';
        otherTh.style.maxWidth = newW + 'px';
        const otherTable = otherTh.closest('table');
        const otherCi = Array.from(otherTh.parentElement.children).indexOf(otherTh);
        const otherTds = otherTable.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (otherCi + 1) + ')');
        for (const td of otherTds) {
          td.style.width = newW + 'px';
          td.style.minWidth = newW + 'px';
          td.style.maxWidth = newW + 'px';
        }
      });
    }
  }
  document.addEventListener('mousedown', function(e) {
    const handle = e.target.closest('.col-resize');
    if (!handle) return;
    e.preventDefault();
    e.stopPropagation();
    th = handle.parentElement;
    colIdx = parseInt(handle.dataset.ci);
    resizing = true;
    startX = e.pageX;
    startW = th.getBoundingClientRect().width;
    document.body.classList.add('resizing');
  });
  document.addEventListener('mousemove', function(e) {
    if (!resizing) return;
    e.preventDefault();
    const newW = Math.max(10, startW + (e.pageX - startX));
    applyColWidth(newW);
  });
  document.addEventListener('mouseup', function() {
    if (!resizing) return;
    resizing = false; th = null; colIdx = -1;
    document.body.classList.remove('resizing');
  });
})();
</script>
</body>
</html>
