<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WC3 Object Editor</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:'Segoe UI',sans-serif;background:#1a1a2e;color:#e0e0e0;font-size:13px}

/* Header */
.hdr{background:#16213e;padding:8px 14px;display:flex;align-items:center;gap:10px;border-bottom:2px solid #0f3460;flex-wrap:wrap}
.hdr h1{font-size:17px;color:#e94560;white-space:nowrap}
.btn{padding:5px 12px;border:1px solid #0f3460;border-radius:3px;cursor:pointer;font-size:12px;font-family:inherit;transition:.12s}
.b-load{background:#0f3460;color:#fff}.b-load:hover{background:#1a5276}
.b-exp{background:#1b6b3a;color:#fff;border-color:#1b6b3a}.b-exp:hover{background:#27ae60}
.b-imp{background:#6b3a1b;color:#fff;border-color:#6b3a1b}.b-imp:hover{background:#ae6027}
.b-add{background:#7d6608;color:#fff;border-color:#7d6608}.b-add:hover{background:#b7950b}
.b-del{background:#922b21;color:#fff;border-color:#922b21}.b-del:hover{background:#c0392b}
.b-sm{padding:2px 6px;font-size:11px}

/* Tabs */
.tabs{display:flex;background:#16213e;border-bottom:1px solid #0f3460;padding:0 14px}
.tab{padding:7px 16px;cursor:pointer;border-bottom:2px solid transparent;color:#888}
.tab:hover{color:#ccc}.tab.active{color:#e94560;border-bottom-color:#e94560}

/* Toolbar */
.toolbar{padding:6px 14px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.search{padding:4px 8px;background:#252550;border:1px solid #0f3460;color:#e0e0e0;border-radius:3px;font-size:12px;width:180px}
.search:focus{border-color:#e94560;outline:none}
.stats{color:#777;font-size:11px;margin-left:auto}

/* Table */
.tw{overflow:auto;max-height:calc(100vh - 140px);margin:0 14px 14px;border:1px solid #0f3460;border-radius:3px}
table{border-collapse:separate;border-spacing:0;table-layout:fixed}
th{background:#0f3460;color:#ddd;padding:4px 6px;text-align:left;position:sticky;top:0;z-index:10;font-size:11px;white-space:nowrap;border-right:1px solid #1a2a4e;cursor:default;min-width:10px;overflow:hidden;text-overflow:ellipsis}
th .sub{font-size:9px;color:#7799bb;display:block;font-weight:normal}
th .col-resize{position:absolute;right:0;top:0;width:6px;height:100%;cursor:col-resize;z-index:11}
th .col-resize:hover{background:rgba(233,69,96,0.5)}
td{padding:1px 2px;border-bottom:1px solid #252550;border-right:1px solid #1e1e3e;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
td input{width:100%;background:transparent;color:#e0e0e0;border:1px solid transparent;padding:1px 3px;font:12px Consolas,monospace;border-radius:2px}
td input:focus{border-color:#e94560;background:#25255a;outline:none}
td select{width:100%;background:#1a1a30;color:#e0e0e0;border:1px solid transparent;padding:1px 3px;font:12px Consolas,monospace;border-radius:2px;cursor:pointer}
td select:focus{border-color:#e94560;background:#25255a;outline:none}
.resizing{cursor:col-resize!important;user-select:none!important}
.r0{background:#1a1a30}.r1{background:#1a2a1a}
.r0:hover{background:#222248}.r1:hover{background:#223a22}
.ga.r0{background:#1e1e38}.ga.r1{background:#1e301e}
.ga.r0:hover{background:#282850}.ga.r1:hover{background:#284028}
.idc{font:12px Consolas,monospace;color:#7fb3d8;padding:2px 4px}
.del-c{text-align:center;padding:0}
.sub-row td{border-bottom:1px solid #1a1a30}
.sub-row .sr-pad{border-right:none}
.sub-row .sr-lvl{color:#6a6a9a;font-size:11px;text-align:center;padding-left:4px}
.grp-head{border-top:2px solid #2a2a5a}
.ro-cell{color:#555;font:12px Consolas,monospace;padding:1px 4px;background:black}

/* Nested level sub-table */
.sub-table-row>td{padding:0 0 4px 30px!important;border-bottom:2px solid #2a2a5a;background:rgba(0,0,0,.25)}
.level-table{border-collapse:separate;border-spacing:0;table-layout:fixed;width:auto;margin:0;opacity:.72}
.level-table th{background:#08162e;color:#667788;padding:2px 5px;text-align:left;font-size:9px;white-space:nowrap;border-right:1px solid #152030;position:sticky;top:0;z-index:5;min-width:10px;overflow:hidden;text-overflow:ellipsis;font-weight:normal;letter-spacing:.3px;text-transform:uppercase}
.level-table th .sub{font-size:8px;color:#3a4a5a;display:block;font-weight:normal}
.level-table th .col-resize{position:absolute;right:0;top:0;width:6px;height:100%;cursor:col-resize;z-index:6}
.level-table th .col-resize:hover{background:rgba(233,69,96,0.4)}
.level-table td{padding:1px 2px;border-bottom:1px solid #151528;border-right:1px solid #151520;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.level-table td input{width:100%;background:transparent;color:#aab0b8;border:1px solid transparent;padding:1px 3px;font:11px Consolas,monospace;border-radius:2px}
.level-table td input:focus{border-color:#e94560;background:#1e1e40;outline:none;color:#e0e0e0}
.level-table td select{width:100%;background:#12121e;color:#aab0b8;border:1px solid transparent;padding:1px 3px;font:11px Consolas,monospace;border-radius:2px;cursor:pointer}
.level-table td select:focus{border-color:#e94560;background:#1e1e40;outline:none;color:#e0e0e0}
.level-table .sr-lvl{color:#4a4a6a;font-size:10px;text-align:center;padding:1px 4px;font-family:Consolas,monospace}
.level-table tr:hover{opacity:1}
.level-table tr:hover td input,.level-table tr:hover td select{color:#e0e0e0}

.hidden{display:none!important}

/* Popup */
.ov{position:fixed;inset:0;background:rgba(0,0,0,.55);z-index:100;display:flex;align-items:center;justify-content:center}
.pop{background:#1a1a2e;border:1px solid #0f3460;border-radius:6px;padding:16px;min-width:320px;max-width:460px;max-height:80vh;overflow-y:auto}
.pop h3{margin-bottom:10px;color:#e94560;font-size:14px}
.pop label{display:block;margin:5px 0 2px;font-size:11px;color:#999}
.pop input,.pop select{width:100%;padding:5px 7px;background:#252550;border:1px solid #0f3460;color:#e0e0e0;border-radius:3px;font-size:12px}
.pop .pb{margin-top:12px;display:flex;gap:6px;justify-content:flex-end}
</style>
</head>
<body>

<div class="hdr">
  <h1>WC3 Object Editor</h1>
  <button class="btn b-load" onclick="loadFile()">📂 Load File</button>
  <span style="border-left:1px solid #0f3460;height:20px"></span>
  <button class="btn b-exp" onclick="exportBinary()">💾 Save File</button>
  <span style="border-left:1px solid #0f3460;height:20px"></span>
  <button class="btn b-imp" onclick="loadJSONFile()" title="Import from JSON (legacy)">Import JSON</button>
  <button class="btn b-imp" onclick="exportJSON()" title="Export current tab as JSON (debug)">Export JSON</button>
</div>

<div class="tabs">
  <div class="tab active" data-t="items" onclick="switchTab('items')">Items (not loaded)</div>
  <div class="tab" data-t="abilities" onclick="switchTab('abilities')">Abilities (not loaded)</div>
  <div class="tab" data-t="units" onclick="switchTab('units')">Units (not loaded)</div>
  <div class="tab" data-t="buffs" onclick="switchTab('buffs')">Buffs (not loaded)</div>
  <div class="tab" data-t="upgrades" onclick="switchTab('upgrades')">Upgrades (not loaded)</div>
  <div class="tab" data-t="destructables" onclick="switchTab('destructables')">Destructables (not loaded)</div>
  <div class="tab" data-t="doodads" onclick="switchTab('doodads')">Doodads (not loaded)</div>
</div>

<div class="toolbar">
  <button class="btn b-add b-sm" onclick="showAddRow()">+ Add Row (Experimental)</button>
  <input class="search" id="searchBox" placeholder="Search..." oninput="filterRows()">
  <span class="stats" id="statsBar"></span>
</div>

<div id="itemsPane" class="tab-pane">
  <p style="color:#555;padding:20px">Load a .w3t file to begin editing items.</p>
</div>
<div id="abilitiesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3a file to begin editing abilities.</p>
</div>
<div id="unitsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3u file to begin editing units.</p>
</div>
<div id="buffsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3h file to begin editing buffs/effects.</p>
</div>
<div id="upgradesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3q file to begin editing upgrades.</p>
</div>
<div id="destructablesPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3b file to begin editing destructables.</p>
</div>
<div id="doodadsPane" class="tab-pane hidden">
  <p style="color:#555;padding:20px">Load a .w3d file to begin editing doodads.</p>
</div>

<!-- Add Row popup -->
<div class="ov hidden" id="popRow">
<div class="pop">
  <h3 id="popRowTitle">Add New Item</h3>
  <label>Base ID (4 chars)</label>
  <input id="arBase" maxlength="4" placeholder="ratf">
  <label>Table</label>
  <select id="arTable"><option value="custom">Custom</option><option value="original">Original</option></select>
  <div id="arLevelWrap">
    <label>Number of levels (abilities only)</label>
    <input id="arLevels" type="number" value="1" min="1" max="20">
  </div>
  <div class="pb">
    <button class="btn b-del b-sm" onclick="closePopup('popRow')">Cancel</button>
    <button class="btn b-exp b-sm" onclick="confirmAddRow()">Add</button>
  </div>
</div></div>


<script>
// ================================================================
// KNOWN FIELD DEFINITIONS   id -> { n: human name, t: default type }
// ================================================================
const KNOWN = {
  // -- Units/Items --
  iabi:{n:"Abilities",t:"abilityList"},
  iarm:{n:"Armor Type",t:"armorType"},
  icid:{n:"Cooldown Group",t:"abilCode"},
  icla:{n:"Classification",t:"itemClass"},
  iclb:{n:"Tinting Color 3 (Blue)",t:"int"},
  iclg:{n:"Tinting Color 2 (Green)",t:"int"},
  iclr:{n:"Tinting Color 1 (Red)",t:"int"},
  ides:{n:"Description",t:"string"},
  idro:{n:"Can Be Dropped",t:"bool"},
  idrp:{n:"Dropped When Carrier Dies",t:"bool"},
  ifil:{n:"Model Used",t:"model"},
  igol:{n:"Gold Cost",t:"int"},
  ihtp:{n:"Hit Points",t:"int"},
  iicd:{n:"Ignore Cooldown",t:"bool"},
  iico:{n:"Interface Icon",t:"icon"},
  ilev:{n:"Level",t:"int"},
  ilum:{n:"Lumber Cost",t:"int"},
  ilvo:{n:"Level (Unclassified)",t:"int"},
  imor:{n:"Valid Target For Transformation",t:"bool"},
  ipaw:{n:"Can Be Sold To Merchants",t:"bool"},
  iper:{n:"Perishable",t:"bool"},
  ipow:{n:"Use Automatically When Acquired",t:"bool"},
  ipri:{n:"Priority",t:"int"},
  iprn:{n:"Include As Random Choice",t:"bool"},
  isca:{n:"Scaling Value",t:"real"},
  isel:{n:"Can Be Sold By Merchants",t:"bool"},
  issc:{n:"Selection Size - Editor",t:"real"},
  isst:{n:"Stock Start Delay",t:"int"},
  isto:{n:"Stock Maximum",t:"int"},
  istr:{n:"Stock Replenish Interval",t:"int"},
  iusa:{n:"Actively Used",t:"bool"},
  iuse:{n:"Number of Charges",t:"int"},
  ua1b:{n:"Attack 1 - Damage Base",t:"int"},
  ua1c:{n:"Attack 1 - Cooldown Time",t:"unreal"},
  ua1d:{n:"Attack 1 - Damage Number of Dice",t:"int"},
  ua1f:{n:"Attack 1 - Area of Effect (Full Damage)",t:"int"},
  ua1g:{n:"Attack 1 - Targets Allowed",t:"targetList"},
  ua1h:{n:"Attack 1 - Area of Effect (Medium Damage)",t:"int"},
  ua1m:{n:"Attack 1 - Projectile Art",t:"model"},
  ua1p:{n:"Attack 1 - Area of Effect Targets",t:"targetList"},
  ua1q:{n:"Attack 1 - Area of Effect (Small Damage)",t:"int"},
  ua1r:{n:"Attack 1 - Range",t:"int"},
  ua1s:{n:"Attack 1 - Damage Sides per Die",t:"int"},
  ua1t:{n:"Attack 1 - Attack Type",t:"attackType"},
  ua1w:{n:"Attack 1 - Weapon Type",t:"weaponType"},
  ua1z:{n:"Attack 1 - Projectile Speed",t:"int"},
  ua2b:{n:"Attack 2 - Damage Base",t:"int"},
  ua2c:{n:"Attack 2 - Cooldown Time",t:"unreal"},
  ua2d:{n:"Attack 2 - Damage Number of Dice",t:"int"},
  ua2f:{n:"Attack 2 - Area of Effect (Full Damage)",t:"int"},
  ua2g:{n:"Attack 2 - Targets Allowed",t:"targetList"},
  ua2h:{n:"Attack 2 - Area of Effect (Medium Damage)",t:"int"},
  ua2m:{n:"Attack 2 - Projectile Art",t:"model"},
  ua2p:{n:"Attack 2 - Area of Effect Targets",t:"targetList"},
  ua2q:{n:"Attack 2 - Area of Effect (Small Damage)",t:"int"},
  ua2r:{n:"Attack 2 - Range",t:"int"},
  ua2s:{n:"Attack 2 - Damage Sides per Die",t:"int"},
  ua2t:{n:"Attack 2 - Attack Type",t:"attackType"},
  ua2w:{n:"Attack 2 - Weapon Type",t:"weaponType"},
  ua2z:{n:"Attack 2 - Projectile Speed",t:"int"},
  uaap:{n:"Required Animation Names - Attachments",t:"stringList"},
  uabi:{n:"Normal",t:"abilityList"},
  uabr:{n:"AI Placement Radius",t:"unreal"},
  uabt:{n:"AI Placement Type",t:"aiBuffer"},
  uacq:{n:"Acquisition Range",t:"unreal"},
  uaen:{n:"Attacks Enabled",t:"attackBits"},
  uagi:{n:"Starting Agility",t:"int"},
  uagp:{n:"Agility per Level",t:"unreal"},
  ualp:{n:"Required Attachment Link Names",t:"stringList"},
  uamn:{n:"Minimum Attack Range",t:"int"},
  uani:{n:"Required Animation Names",t:"stringList"},
  uarm:{n:"Armor Type",t:"armorType"},
  uawt:{n:"Tooltip - Awaken",t:"string"},
  ubba:{n:"Gold Bounty Awarded - Base",t:"int"},
  ubdg:{n:"Is a Building",t:"bool"},
  ubdi:{n:"Gold Bounty Awarded - Number of Dice",t:"int"},
  ubld:{n:"Build Time",t:"int"},
  uble:{n:"Animation - Blend Time (seconds)",t:"real"},
  ubpr:{n:"Required Bone Names",t:"stringList"},
  ubpx:{n:"Button Position (X)",t:"int"},
  ubpy:{n:"Button Position (Y)",t:"int"},
  ubs1:{n:"Attack 1 - Animation Backswing Point",t:"unreal"},
  ubs2:{n:"Attack 2 - Animation Backswing Point",t:"unreal"},
  ubsi:{n:"Gold Bounty Awarded - Sides per Die",t:"int"},
  ubsl:{n:"Construction",t:"soundLabel"},
  ubui:{n:"Structures Built",t:"unitList"},
  ucam:{n:"Categorization - Campaign",t:"bool"},
  ucar:{n:"Transported Size",t:"int"},
  ucbo:{n:"Can Build On",t:"bool"},
  ucbs:{n:"Animation - Cast Backswing",t:"unreal"},
  uclb:{n:"Tinting Color 3 (Blue)",t:"int"},
  uclg:{n:"Tinting Color 2 (Green)",t:"int"},
  uclr:{n:"Tinting Color 1 (Red)",t:"int"},
  ucol:{n:"Collision Size",t:"unreal"},
  ucpt:{n:"Animation - Cast Point",t:"unreal"},
  ucs1:{n:"Attack 1 - Weapon Sound",t:"combatSound"},
  ucs2:{n:"Attack 2 - Weapon Sound",t:"combatSound"},
  ucua:{n:"Caster Upgrade Art",t:"icon"},
  ucun:{n:"Caster Upgrade Names",t:"stringList"},
  ucut:{n:"Caster Upgrade Tips",t:"stringList"},
  udaa:{n:"Default Active Ability",t:"abilCode"},
  udea:{n:"Death Type",t:"deathType"},
  udef:{n:"Defense Base",t:"int"},
  udep:{n:"Dependency Equivalents",t:"unitList"},
  udl1:{n:"Attack 1 - Damage Loss Factor",t:"unreal"},
  udl2:{n:"Attack 2 - Damage Loss Factor",t:"unreal"},
  udp1:{n:"Attack 1 - Animation Damage Point",t:"unreal"},
  udp2:{n:"Attack 2 - Animation Damage Point",t:"unreal"},
  udro:{n:"Can Drop Items On Death",t:"bool"},
  udtm:{n:"Death Time (seconds)",t:"unreal"},
  udty:{n:"Defense Type",t:"defenseType"},
  udu1:{n:"Attack 1 - Damage Upgrade Amount",t:"int"},
  udu2:{n:"Attack 2 - Damage Upgrade Amount",t:"int"},
  udup:{n:"Defense Upgrade Bonus",t:"int"},
  uept:{n:"Elevation - Sample Points",t:"int"},
  uerd:{n:"Elevation - Sample Radius",t:"real"},
  ufle:{n:"Can Flee",t:"bool"},
  ufma:{n:"Food Produced",t:"int"},
  ufoo:{n:"Food Cost",t:"int"},
  ufor:{n:"Formation Rank",t:"int"},
  ufrd:{n:"Fog of War - Sample Radius",t:"real"},
  ugol:{n:"Gold Cost",t:"int"},
  ugor:{n:"Repair Gold Cost",t:"int"},
  uhab:{n:"Hero",t:"heroAbilityList"},
  uhd1:{n:"Attack 1 - Damage Factor - Medium",t:"unreal"},
  uhd2:{n:"Attack 2 - Damage Factor - Medium",t:"unreal"},
  uhhb:{n:"Hero - Hide Hero Interface Icon",t:"bool"},
  uhhd:{n:"Hero - Hide Hero Death Message",t:"bool"},
  uhhm:{n:"Hero - Hide Hero Minimap Display",t:"bool"},
  uhom:{n:"Hide Minimap Display",t:"bool"},
  uhos:{n:"Display as Neutral Hostile",t:"bool"},
  uhot:{n:"Hotkey",t:"char"},
  uhpm:{n:"Hit Points Maximum (Base)",t:"int"},
  uhpr:{n:"Hit Points Regeneration Rate",t:"unreal"},
  uhrt:{n:"Hit Points Regeneration Type",t:"regenType"},
  uibo:{n:"Can Be Built On",t:"bool"},
  uico:{n:"Icon - Game Interface",t:"icon"},
  uimz:{n:"Projectile Impact - Z",t:"unreal"},
  uine:{n:"Placeable In Editor",t:"bool"},
  uinp:{n:"Intelligence per Level",t:"unreal"},
  uint:{n:"Starting Intelligence",t:"int"},
  uisz:{n:"Projectile Impact - Z (Swimming)",t:"unreal"},
  ulba:{n:"Lumber Bounty Awarded - Base",t:"int"},
  ulbd:{n:"Lumber Bounty Awarded - Number of Dice",t:"int"},
  ulbs:{n:"Lumber Bounty Awarded - Sides per Die",t:"int"},
  ulev:{n:"Level",t:"int"},
  ulfi:{n:"Looping Fade In Rate",t:"int"},
  ulfo:{n:"Looping Fade Out Rate",t:"int"},
  ulos:{n:"Use Extended Line of Sight",t:"bool"},
  ulpx:{n:"Projectile Launch - X",t:"unreal"},
  ulpy:{n:"Projectile Launch - Y",t:"unreal"},
  ulpz:{n:"Projectile Launch - Z",t:"unreal"},
  ulsz:{n:"Projectile Launch - Z (Swimming)",t:"unreal"},
  ulum:{n:"Lumber Cost",t:"int"},
  ulur:{n:"Repair Lumber Cost",t:"int"},
  uma1:{n:"Attack 1 - Projectile Arc",t:"unreal"},
  uma2:{n:"Attack 2 - Projectile Arc",t:"unreal"},
  umas:{n:"Speed Maximum",t:"int"},
  umdl:{n:"Model File",t:"model"},
  umh1:{n:"Attack 1 - Projectile Homing Enabled",t:"bool"},
  umh2:{n:"Attack 2 - Projectile Homing Enabled",t:"bool"},
  umis:{n:"Speed Minimum",t:"int"},
  umki:{n:"Items Made",t:"itemList"},
  umpi:{n:"Mana Initial Amount",t:"int"},
  umpm:{n:"Mana Maximum",t:"int"},
  umpr:{n:"Mana Regeneration",t:"unreal"},
  umsl:{n:"Movement",t:"soundLabel"},
  umvf:{n:"Height Minimum",t:"unreal"},
  umvh:{n:"Height",t:"unreal"},
  umvr:{n:"Turn Rate",t:"unreal"},
  umvs:{n:"Speed Base",t:"int"},
  umvt:{n:"Type",t:"moveType"},
  umxp:{n:"Maximum Pitch Angle (degrees)",t:"real"},
  umxr:{n:"Maximum Roll Angle (degrees)",t:"real"},
  unam:{n:"Name",t:"string"},
  unbm:{n:"Neutral Building - Shows Minimap Icon",t:"bool"},
  unbr:{n:"Neutral Building - Valid As Random Building",t:"bool"},
  unsf:{n:"Name - Editor Suffix",t:"string"},
  uocc:{n:"Occluder Height",t:"unreal"},
  uori:{n:"Orientation Interpolation",t:"int"},
  upap:{n:"Placement Requires",t:"pathingListPrevent"},
  upar:{n:"Placement Prevented By",t:"pathingListRequire"},
  upat:{n:"Pathing Map",t:"pathingTexture"},
  upaw:{n:"Placement Requires Water Radius",t:"unreal"},
  upgr:{n:"Upgrades Used",t:"upgradeList"},
  upoi:{n:"Point Value",t:"int"},
  upra:{n:"Primary Attribute",t:"attributeType"},
  upri:{n:"Priority",t:"int"},
  upro:{n:"Proper Names",t:"stringList"},
  upru:{n:"Proper Names Used",t:"int"},
  uprw:{n:"Propulsion Window (degrees)",t:"unreal"},
  uqd1:{n:"Attack 1 - Damage Factor - Small",t:"unreal"},
  uqd2:{n:"Attack 2 - Damage Factor - Small",t:"unreal"},
  urac:{n:"Race",t:"unitRace"},
  urb1:{n:"Attack 1 - Range Motion Buffer",t:"unreal"},
  urb2:{n:"Attack 2 - Range Motion Buffer",t:"unreal"},
  ureq:{n:"Requirements",t:"techList"},
  ures:{n:"Researches Available",t:"upgradeList"},
  urev:{n:"Revives Dead Heros",t:"bool"},
  urpg:{n:"Group Separation - Group Number",t:"int"},
  urpo:{n:"Group Separation - Enabled",t:"bool"},
  urpp:{n:"Group Separation - Parameter",t:"int"},
  urpr:{n:"Group Separation - Priority",t:"int"},
  urq1:{n:"Requirements - Tier 2",t:"techList"},
  urq2:{n:"Requirements - Tier 3",t:"techList"},
  urq3:{n:"Requirements - Tier 4",t:"techList"},
  urq4:{n:"Requirements - Tier 5",t:"techList"},
  urq5:{n:"Requirements - Tier 6",t:"techList"},
  urq6:{n:"Requirements - Tier 7",t:"techList"},
  urq7:{n:"Requirements - Tier 8",t:"techList"},
  urq8:{n:"Requirements - Tier 9",t:"techList"},
  urqa:{n:"Requirements - Levels",t:"intList"},
  urqc:{n:"Requirements - Tiers Used",t:"int"},
  ursl:{n:"Random",t:"soundLabel"},
  urtm:{n:"Repair Time",t:"int"},
  urun:{n:"Animation - Run Speed",t:"real"},
  urva:{n:"Hero Revival Locations",t:"unitList"},
  usca:{n:"Scaling Value",t:"real"},
  uscb:{n:"Scale Projectiles",t:"bool"},
  usd1:{n:"Attack 1 - Damage Spill Distance",t:"unreal"},
  usd2:{n:"Attack 2 - Damage Spill Distance",t:"unreal"},
  usei:{n:"Items Sold",t:"itemList"},
  useu:{n:"Units Sold",t:"unitList"},
  usew:{n:"Selection Circle On Water",t:"bool"},
  ushb:{n:"Shadow Texture (Building)",t:"shadowTexture"},
  ushh:{n:"Shadow Image - Height",t:"real"},
  ushr:{n:"Has Water Shadow",t:"bool"},
  ushu:{n:"Shadow Image (Unit)",t:"shadowImage"},
  ushw:{n:"Shadow Image - Width",t:"real"},
  ushx:{n:"Shadow Image - Center X",t:"real"},
  ushy:{n:"Shadow Image - Center Y",t:"real"},
  usid:{n:"Sight Radius (Day)",t:"int"},
  usin:{n:"Sight Radius (Night)",t:"int"},
  usle:{n:"Sleeps",t:"bool"},
  uslz:{n:"Selection Circle - Height",t:"real"},
  usma:{n:"Stock Maximum",t:"int"},
  usnd:{n:"Unit Sound Set",t:"unitSound"},
  uspa:{n:"Special",t:"modelList"},
  uspe:{n:"Categorization - Special",t:"bool"},
  usr1:{n:"Attack 1 - Damage Spill Radius",t:"unreal"},
  usr2:{n:"Attack 2 - Damage Spill Radius",t:"unreal"},
  usrg:{n:"Stock Replenish Interval",t:"int"},
  ussc:{n:"Selection Scale",t:"real"},
  ussi:{n:"Icon - Score Screen",t:"icon"},
  usst:{n:"Stock Start Delay",t:"int"},
  ustp:{n:"Strength per Level",t:"unreal"},
  ustr:{n:"Starting Strength",t:"int"},
  utaa:{n:"Target",t:"modelList"},
  utar:{n:"Targeted as",t:"targetList"},
  utc1:{n:"Attack 1 - Maximum Number of Targets",t:"int"},
  utc2:{n:"Attack 2 - Maximum Number of Targets",t:"int"},
  utcc:{n:"Allow Custom Team Color",t:"bool"},
  utco:{n:"Team Color",t:"teamColor"},
  util:{n:"Tilesets",t:"tilesetList"},
  utip:{n:"Tooltip - Basic",t:"string"},
  utpr:{n:"Tooltip - Revive",t:"string"},
  utra:{n:"Units Trained",t:"unitList"},
  utss:{n:"Has Tileset Specific Data",t:"bool"},
  utub:{n:"Tooltip - Extended",t:"string"},
  utyp:{n:"Unit Classification",t:"unitClass"},
  uubs:{n:"Ground Texture",t:"uberSplat"},
  uuch:{n:"Use Click Helper",t:"bool"},
  uupt:{n:"Upgrades To",t:"unitList"},
  uver:{n:"Model File - Extra Versions",t:"versionFlags"},
  uwal:{n:"Animation - Walk Speed",t:"real"},
  uwu1:{n:"Attack 1 - Show UI",t:"bool"},
  uwu2:{n:"Attack 2 - Show UI",t:"bool"},
  // -- Abilities --
  aaea:{n:"Area Effect",t:"modelList"},
  aani:{n:"Animation Names",t:"stringList"},
  aare:{n:"Area of Effect",t:"unreal"},
  aart:{n:"Icon - Normal",t:"icon"},
  abpx:{n:"Button Position - Normal (X)",t:"int"},
  abpy:{n:"Button Position - Normal (Y)",t:"int"},
  abs1:{n:"Maximum Life Absorbed",t:"unreal"},
  abs2:{n:"Maximum Mana Absorbed",t:"unreal"},
  abuf:{n:"Buffs",t:"buffList"},
  aca1:{n:"Caster Attachment Point 2",t:"stringList"},
  acac:{n:"Caster Attachments",t:"int"},
  acap:{n:"Caster Attachment Point 1",t:"stringList"},
  acas:{n:"Casting Time",t:"unreal"},
  acat:{n:"Caster",t:"modelList"},
  acdn:{n:"Cooldown",t:"unreal"},
  achd:{n:"Check Dependencies",t:"bool"},
  Adm1:{n:"Mana Loss",t:"unreal"},
  Adm2:{n:"Summoned Unit Damage",t:"unreal"},
  adur:{n:"Duration - Normal",t:"unreal"},
  aeat:{n:"Effect",t:"modelList"},
  aeff:{n:"Effects",t:"effectList"},
  aefl:{n:"Effect Sound (Looping)",t:"soundLabel"},
  aefs:{n:"Effect Sound",t:"soundLabel"},
  ahdu:{n:"Duration - Hero",t:"unreal"},
  aher:{n:"Hero Ability",t:"bool"},
  ahky:{n:"Hotkey - Normal",t:"char"},
  aite:{n:"Item Ability",t:"bool"},
  Akb1:{n:"Attack Damage Increase",t:"unreal"},
  alev:{n:"Levels",t:"int"},
  alig:{n:"Lightning Effects",t:"lightningList"},
  alsk:{n:"Level Skip Requirement",t:"int"},
  amac:{n:"Missile Arc",t:"unreal"},
  amat:{n:"Missile Art",t:"modelList"},
  amcs:{n:"Mana Cost",t:"int"},
  amho:{n:"Missile Homing Enabled",t:"bool"},
  Ams1:{n:"Summoned Unit Damage",t:"unreal"},
  Ams2:{n:"Magic Damage Reduction",t:"unreal"},
  Ams3:{n:"Shield Life",t:"int"},
  Ams4:{n:"Mana Loss",t:"int"},
  amsp:{n:"Missile Speed",t:"int"},
  anam:{n:"Name",t:"string"},
  Ans5:{n:"Base Order ID",t:"orderString"},
  Ans6:{n:"Charge Owning Player",t:"bool"},
  ansf:{n:"Editor Suffix",t:"string"},
  aord:{n:"Order String - Use/Turn On",t:"orderString"},
  aorf:{n:"Order String - Deactivate",t:"orderString"},
  aoro:{n:"Order String - Activate",t:"orderString"},
  aoru:{n:"Order String - Turn Off",t:"orderString"},
  Apl1:{n:"Aura Duration",t:"unreal"},
  Apl2:{n:"Damage per Second",t:"unreal"},
  Apl3:{n:"Duration of Plague Ward",t:"unreal"},
  Aplu:{n:"Plague Ward Unit Type",t:"unitCode"},
  apri:{n:"Priority for Spell Steal",t:"int"},
  arac:{n:"Race",t:"unitRace"},
  aran:{n:"Cast Range",t:"unreal"},
  arar:{n:"Icon - Research",t:"icon"},
  areq:{n:"Requirements",t:"techList"},
  aret:{n:"Tooltip - Learn",t:"string"},
  arhk:{n:"Hotkey - Learn",t:"char"},
  arlv:{n:"Required Level",t:"int"},
  Arm1:{n:"Amount Regenerated",t:"unreal"},
  Arm2:{n:"Percentage",t:"bool"},
  arpx:{n:"Button Position - Research (X)",t:"int"},
  arpy:{n:"Button Position - Research (Y)",t:"int"},
  arqa:{n:"Requirements - Levels",t:"intList"},
  arut:{n:"Tooltip - Learn - Extended",t:"string"},
  asat:{n:"Special",t:"modelList"},
  aspt:{n:"Special Attachment Point",t:"stringList"},
  ast1:{n:"Life Restored Factor",t:"unreal"},
  ast2:{n:"Mana Restored Factor",t:"unreal"},
  ata0:{n:"Target Attachment Point 1",t:"stringList"},
  ata1:{n:"Target Attachment Point 2",t:"stringList"},
  ata2:{n:"Target Attachment Point 3",t:"stringList"},
  ata3:{n:"Target Attachment Point 4",t:"stringList"},
  ata4:{n:"Target Attachment Point 5",t:"stringList"},
  ata5:{n:"Target Attachment Point 6",t:"stringList"},
  atac:{n:"Target Attachments",t:"int"},
  atar:{n:"Targets Allowed",t:"targetList"},
  atat:{n:"Target",t:"modelList"},
  atp1:{n:"Tooltip - Normal",t:"string"},
  auar:{n:"Icon - Turn Off",t:"icon"},
  aub1:{n:"Tooltip - Normal - Extended",t:"string"},
  aubx:{n:"Button Position - Turn Off (X)",t:"int"},
  auby:{n:"Button Position - Turn Off (Y)",t:"int"},
  auhk:{n:"Hotkey - Turn Off",t:"char"},
  aut1:{n:"Tooltip - Turn Off",t:"string"},
  auu1:{n:"Tooltip - Turn Off - Extended",t:"string"},
  ave5:{n:"Life Regeneration Rate (per second)",t:"unreal"},
  Bgm1:{n:"Gold per Interval",t:"int"},
  Bgm2:{n:"Interval Duration",t:"unreal"},
  Bgm3:{n:"Max Number of Miners",t:"int"},
  Bgm4:{n:"Radius of Mining Ring",t:"unreal"},
  Bli1:{n:"Expansion Amount",t:"unreal"},
  Bli2:{n:"Creates Blight",t:"bool"},
  Blo1:{n:"Attack Speed Increase (%)",t:"unreal"},
  Blo2:{n:"Movement Speed Increase (%)",t:"unreal"},
  Blo3:{n:"Scaling Factor",t:"unreal"},
  bsk1:{n:"Movement Speed Increase",t:"unreal"},
  bsk2:{n:"Attack Speed Increase",t:"unreal"},
  bsk3:{n:"Damage Taken Increase",t:"unreal"},
  Btl1:{n:"Allowed Unit Type",t:"unitCode"},
  Btl2:{n:"Summon Busy Units",t:"bool"},
  Cac1:{n:"Attack Damage Increase",t:"unreal"},
  Cad1:{n:"Number of Corpses Raised",t:"int"},
  Can1:{n:"Hit Points per Second",t:"unreal"},
  Can2:{n:"Max Hit Points",t:"unreal"},
  Car1:{n:"Cargo Capacity",t:"int"},
  Cha1:{n:"New Unit Type",t:"unitCode"},
  Chd1:{n:"Movement Update Frequency",t:"unreal"},
  Chd2:{n:"Attack Update Frequency",t:"unreal"},
  Chd3:{n:"Summoned Unit Damage",t:"unreal"},
  Chl1:{n:"Unit Type Allowed",t:"unitCode"},
  Cmg2:{n:"Mana per Summoned Hitpoint",t:"unreal"},
  Cmg3:{n:"Charge for Current Life",t:"unreal"},
  coa1:{n:"Partner Unit Type",t:"unitCode"},
  coa2:{n:"Move To Partner",t:"bool"},
  coau:{n:"Resulting Unit Type",t:"unitCode"},
  Cor1:{n:"Damage Per Second",t:"unreal"},
  Cri1:{n:"Movement Speed Reduction (%)",t:"unreal"},
  Cri2:{n:"Attack Speed Reduction (%)",t:"unreal"},
  Cri3:{n:"Damage Reduction",t:"unreal"},
  Crs:{n:"Chance to Miss",t:"unreal"},
  Ctb1:{n:"Damage",t:"unreal"},
  Ctc1:{n:"Damage",t:"unreal"},
  Ctc2:{n:"Extra Damage To Target",t:"unreal"},
  Ctc3:{n:"Movement Speed Reduction",t:"unreal"},
  Ctc4:{n:"Attack Speed Reduction",t:"unreal"},
  cyc1:{n:"Can Be Dispelled",t:"bool"},
  dcp1:{n:"Partner Unit Type One",t:"unitCode"},
  dcp2:{n:"Partner Unit Type Two",t:"unitCode"},
  Dda1:{n:"Full Damage Radius",t:"unreal"},
  Dda2:{n:"Full Damage Amount",t:"unreal"},
  Dda3:{n:"Partial Damage Radius",t:"unreal"},
  Dda4:{n:"Partial Damage Amount",t:"unreal"},
  Def1:{n:"Damage Taken (%)",t:"unreal"},
  Def2:{n:"Damage Dealt (%)",t:"unreal"},
  Def3:{n:"Movement Speed Factor",t:"unreal"},
  Def4:{n:"Attack Speed Factor",t:"unreal"},
  Def5:{n:"Magic Damage Reduction",t:"unreal"},
  Def6:{n:"Chance to Deflect",t:"unreal"},
  Def7:{n:"Deflect Damage Taken (Piercing)",t:"unreal"},
  Def8:{n:"Deflect Damage Taken (Spells)",t:"unreal"},
  Det1:{n:"Detection Type",t:"detectionType"},
  Dev1:{n:"Max Creep Level",t:"int"},
  Dev2:{n:"Damage per Second",t:"unreal"},
  Dev3:{n:"Maximum Creep Level",t:"int"},
  Dtn1:{n:"Mana Loss (per unit)",t:"unreal"},
  Dtn2:{n:"Damage to Summoned Units",t:"unreal"},
  dvm1:{n:"Life Per Unit",t:"unreal"},
  dvm2:{n:"Mana Per Unit",t:"unreal"},
  dvm3:{n:"Life Per Buff",t:"unreal"},
  dvm4:{n:"Mana Per Buff",t:"unreal"},
  dvm5:{n:"Summoned Unit Damage",t:"unreal"},
  dvm6:{n:"Ignore Friendly Buffs",t:"bool"},
  Eah1:{n:"Damage Dealt to Attackers",t:"unreal"},
  Eah2:{n:"Damage is Percent Received",t:"bool"},
  Ear1:{n:"Damage Bonus (%)",t:"unreal"},
  Ear2:{n:"Melee Bonus",t:"bool"},
  Ear3:{n:"Ranged Bonus",t:"bool"},
  Ear4:{n:"Flat Bonus",t:"bool"},
  Eat1:{n:"Rip Delay",t:"unreal"},
  Eat2:{n:"Eat Delay",t:"unreal"},
  Eat3:{n:"Hit Points Gained",t:"unreal"},
  Ebl1:{n:"Maximum Range",t:"unreal"},
  Ebl2:{n:"Minimum Range",t:"unreal"},
  Eer1:{n:"Damage per Second",t:"unreal"},
  Eev1:{n:"Chance to Evade",t:"unreal"},
  Efk1:{n:"Damage Per Target",t:"unreal"},
  Efk2:{n:"Maximum Total Damage",t:"unreal"},
  Efk3:{n:"Maximum Number of Targets",t:"int"},
  Efk4:{n:"Maximum Speed Adjustment",t:"unreal"},
  Efn1:{n:"Number of Summoned Units",t:"int"},
  Efnu:{n:"Summoned Unit Type",t:"unitCode"},
  Egm1:{n:"Gold per Interval",t:"int"},
  Egm2:{n:"Interval Duration",t:"unreal"},
  Eim1:{n:"Damage per Interval",t:"unreal"},
  Eim2:{n:"Mana Drained per Second",t:"unreal"},
  Eim3:{n:"Buffer Mana Required",t:"unreal"},
  Emb1:{n:"Max Mana Drained",t:"unreal"},
  Emb2:{n:"Bolt Delay",t:"unreal"},
  Emb3:{n:"Bolt Lifetime",t:"unreal"},
  Eme1:{n:"Normal Form Unit",t:"unitCode"},
  Eme2:{n:"Morphing Flags",t:"morphFlags"},
  Eme3:{n:"Altitude Adjustment Duration",t:"unreal"},
  Eme4:{n:"Landing Delay Time",t:"unreal"},
  Eme5:{n:"Alternate Form Hit Point Bonus",t:"unreal"},
  Emeu:{n:"Alternate Form Unit",t:"unitCode"},
  Ens1:{n:"Air Unit Lower Duration",t:"unreal"},
  Ens2:{n:"Air Unit Height",t:"unreal"},
  Ens3:{n:"Melee Attack Range",t:"unreal"},
  ent1:{n:"Resulting Unit Type",t:"unitCode"},
  Esf1:{n:"Damage Dealt",t:"unreal"},
  Esf2:{n:"Damage Interval",t:"unreal"},
  Esf3:{n:"Building Reduction",t:"unreal"},
  Esh1:{n:"Decaying Damage",t:"unreal"},
  Esh2:{n:"Movement Speed Factor",t:"unreal"},
  Esh3:{n:"Attack Speed Factor",t:"unreal"},
  Esh4:{n:"Decay Power",t:"unreal"},
  Esh5:{n:"Initial Damage",t:"unreal"},
  Esn1:{n:"In Flight Sight Radius",t:"unreal"},
  Esn2:{n:"Hovering Sight Radius",t:"unreal"},
  Esn3:{n:"Hovering Height",t:"unreal"},
  Esn4:{n:"Number of Owls",t:"int"},
  Esv1:{n:"Number of Summoned Units",t:"int"},
  Esvu:{n:"Summoned Unit Type",t:"unitCode"},
  Eth1:{n:"Immune to Morph Effects",t:"bool"},
  Eth2:{n:"Does Not Block Buildings",t:"bool"},
  Etq1:{n:"Life Healed",t:"unreal"},
  Etq2:{n:"Heal Interval",t:"unreal"},
  Etq3:{n:"Building Reduction",t:"unreal"},
  exh1:{n:"Maximum Number of Corpses",t:"int"},
  exhu:{n:"Unit Type",t:"unitCode"},
  Fae1:{n:"Defense Reduction",t:"int"},
  Fae2:{n:"Always Autocast",t:"bool"},
  fak1:{n:"Damage Bonus",t:"unreal"},
  fak2:{n:"Medium Damage Factor",t:"unreal"},
  fak3:{n:"Small Damage Factor",t:"unreal"},
  fak4:{n:"Full Damage Radius",t:"unreal"},
  fak5:{n:"Half Damage Radius",t:"unreal"},
  fbk1:{n:"Max Mana Drained - Units",t:"unreal"},
  fbk2:{n:"Damage Ratio - Units (%)",t:"unreal"},
  fbk3:{n:"Max Mana Drained - Heros",t:"unreal"},
  fbk4:{n:"Damage Ratio - Heros (%)",t:"unreal"},
  fbk5:{n:"Summoned Damage",t:"unreal"},
  Fla1:{n:"Detection Type",t:"detectionType"},
  Fla2:{n:"Effect Delay",t:"unreal"},
  Fla3:{n:"Flare Count",t:"int"},
  flk1:{n:"Medium Damage Radius",t:"unreal"},
  flk2:{n:"Small Damage Radius",t:"unreal"},
  flk3:{n:"Full Damage Amount",t:"unreal"},
  flk4:{n:"Medium Damage Amount",t:"unreal"},
  flk5:{n:"Small Damage Amount",t:"unreal"},
  Gho1:{n:"Auto-Acquire Attack Targets",t:"bool"},
  Gho2:{n:"Immune to Morph Effects",t:"bool"},
  Gho3:{n:"Does Not Block Buildings",t:"bool"},
  Gld1:{n:"Max Gold",t:"int"},
  Gld2:{n:"Mining Duration",t:"unreal"},
  Gld3:{n:"Mining Capacity",t:"int"},
  gra1:{n:"Attach Delay",t:"unreal"},
  gra2:{n:"Remove Delay",t:"unreal"},
  gra3:{n:"Disabled Attack Index",t:"int"},
  gra4:{n:"Enabled Attack Index",t:"int"},
  gra5:{n:"Maximum Attacks",t:"int"},
  Gyd1:{n:"Maximum Number of Corpses",t:"int"},
  Gyd2:{n:"Radius of Gravestones",t:"unreal"},
  Gyd3:{n:"Radius of Corpses",t:"unreal"},
  Gydu:{n:"Corpse Unit Type",t:"unitCode"},
  Hab1:{n:"Mana Regeneration Increase",t:"unreal"},
  Hab2:{n:"Percent Bonus",t:"bool"},
  Had1:{n:"Armor Bonus",t:"unreal"},
  Had2:{n:"Percent Bonus",t:"bool"},
  Har1:{n:"Damage to Tree",t:"int"},
  Har2:{n:"Lumber Capacity",t:"int"},
  Har3:{n:"Gold Capacity",t:"int"},
  Hav1:{n:"Defense Bonus",t:"unreal"},
  Hav2:{n:"Hit Point Bonus",t:"unreal"},
  Hav3:{n:"Damage Bonus",t:"unreal"},
  Hav4:{n:"Magic Damage Reduction",t:"unreal"},
  Hbh1:{n:"Chance to Bash",t:"unreal"},
  Hbh2:{n:"Damage Multiplier",t:"unreal"},
  Hbh3:{n:"Damage Bonus",t:"unreal"},
  Hbh4:{n:"Chance to Miss",t:"unreal"},
  Hbh5:{n:"Never Miss",t:"bool"},
  Hbn1:{n:"Movement Speed Reduction (%)",t:"unreal"},
  Hbn2:{n:"Attack Speed Reduction (%)",t:"unreal"},
  Hbz1:{n:"Number of Waves",t:"int"},
  Hbz2:{n:"Damage",t:"unreal"},
  Hbz3:{n:"Number of Shards",t:"int"},
  Hbz4:{n:"Building Reduction",t:"unreal"},
  Hbz5:{n:"Damage Per Second",t:"unreal"},
  Hbz6:{n:"Maximum Damage per Wave",t:"unreal"},
  Hca1:{n:"Extra Damage",t:"unreal"},
  Hca2:{n:"Movement Speed Factor",t:"unreal"},
  Hca3:{n:"Attack Speed Factor",t:"unreal"},
  Hca4:{n:"Stack Flags",t:"stackFlags"},
  Hds1:{n:"Can Deactivate",t:"bool"},
  Hea1:{n:"Hit Points Gained",t:"unreal"},
  Hfa1:{n:"Damage Bonus",t:"unreal"},
  Hfs1:{n:"Full Damage Dealt",t:"unreal"},
  Hfs2:{n:"Full Damage Interval",t:"unreal"},
  Hfs3:{n:"Half Damage Dealt",t:"unreal"},
  Hfs4:{n:"Half Damage Interval",t:"unreal"},
  Hfs5:{n:"Building Reduction",t:"unreal"},
  Hfs6:{n:"Maximum Damage",t:"unreal"},
  Hhb1:{n:"Amount Healed/Damaged",t:"unreal"},
  Hmt1:{n:"Number of Units Teleported",t:"int"},
  Hmt2:{n:"Casting Delay",t:"unreal"},
  Hmt3:{n:"Use Teleport Clustering",t:"bool"},
  Hre1:{n:"Number of Corpses Raised",t:"int"},
  Hre2:{n:"Raised Units Are Invulnerable",t:"bool"},
  Htb1:{n:"Damage",t:"unreal"},
  Htc1:{n:"AOE Damage",t:"unreal"},
  Htc2:{n:"Specific Target Damage",t:"unreal"},
  Htc3:{n:"Movement Speed Reduction (%)",t:"unreal"},
  Htc4:{n:"Attack Speed Reduction (%)",t:"unreal"},
  hwdu:{n:"Ward Unit Type",t:"unitCode"},
  Hwe1:{n:"Summoned Unit Type",t:"unitCode"},
  Hwe2:{n:"Summoned Unit Count",t:"int"},
  Iaa1:{n:"Attack Modification",t:"int"},
  Iagi:{n:"Agility Bonus",t:"int"},
  Iarp:{n:"Armor Penalty",t:"int"},
  Iatt:{n:"Attack Bonus",t:"int"},
  Ibl1:{n:"Unit Created (per player race)",t:"unitList"},
  Icfd:{n:"Damage Per Duration",t:"int"},
  Icfm:{n:"Mana Used Per Second",t:"int"},
  Icfx:{n:"Extra Mana Required",t:"int"},
  Icre:{n:"Maximum Creep Level",t:"int"},
  ict1:{n:"New Time of Day - Hour",t:"int"},
  ict2:{n:"New Time of Day - Minute",t:"int"},
  Idam:{n:"Damage Bonus",t:"unreal"},
  idc1:{n:"Mana Loss Per Unit",t:"unreal"},
  idc2:{n:"Summoned Unit Damage",t:"unreal"},
  idc3:{n:"Maximum Dispelled Units",t:"int"},
  Idef:{n:"Defense Bonus",t:"int"},
  Idel:{n:"Delay For Target Effect",t:"unreal"},
  Idet:{n:"Detection Radius",t:"detectionType"},
  Idic:{n:"Damage Bonus Dice",t:"int"},
  Idid:{n:"Damage To Summoned Units",t:"int"},
  Idim:{n:"Mana Loss Per Unit",t:"int"},
  Idps:{n:"Damage Per Second",t:"unreal"},
  Ifa1:{n:"Detection Type",t:"detectionType"},
  Igl1:{n:"Upgrade Levels",t:"int"},
  Iglu:{n:"Upgrade Type",t:"upgradeCode"},
  Ihid:{n:"Hide Button",t:"bool"},
  Ihp2:{n:"Hit Points Gained",t:"int"},
  Ihpg:{n:"Hit Points Gained",t:"int"},
  Ihpr:{n:"Hit Points Regenerated Per Second",t:"int"},
  Ihps:{n:"Hit Points Restored",t:"int"},
  Iild:{n:"Damage Dealt (% of normal)",t:"unreal"},
  Iilw:{n:"Damage Received Multiplier",t:"unreal"},
  Iint:{n:"Intelligence Bonus",t:"int"},
  Ilif:{n:"Max Life Gained",t:"int"},
  Iman:{n:"Max Mana Gained",t:"int"},
  imo1:{n:"Number of Lures",t:"int"},
  imo2:{n:"Activation Delay",t:"unreal"},
  imo3:{n:"Lure Interval (seconds)",t:"unreal"},
  imou:{n:"Lure Unit Type",t:"unitCode"},
  Imp2:{n:"Mana Points Gained",t:"int"},
  Impg:{n:"Mana Points Gained",t:"int"},
  Imps:{n:"Mana Points Restored",t:"int"},
  Imrp:{n:"Mana Regeneration Bonus (as fraction of normal)",t:"unreal"},
  Imvb:{n:"Movement Speed Bonus",t:"int"},
  Inf1:{n:"Damage Increase (%)",t:"unreal"},
  Inf2:{n:"Defense Increase",t:"int"},
  Inf3:{n:"Autocast Range",t:"unreal"},
  Inf4:{n:"Life Regen Rate",t:"unreal"},
  inv1:{n:"Item Capacity",t:"int"},
  inv2:{n:"Drop Items On Death",t:"bool"},
  inv3:{n:"Can Use Items",t:"bool"},
  inv4:{n:"Can Get Items",t:"bool"},
  inv5:{n:"Can Drop Items",t:"bool"},
  Iob2:{n:"Chance To Hit Units (%)",t:"unreal"},
  Iob3:{n:"Chance To Hit Heros (%)",t:"unreal"},
  Iob4:{n:"Chance To Hit Summons (%)",t:"unreal"},
  Iob5:{n:"Enabled Attack Index",t:"int"},
  Iobu:{n:"Effect Ability",t:"abilCode"},
  ipmu:{n:"Unit Type",t:"unitCode"},
  ipv1:{n:"Damage Bonus",t:"unreal"},
  ipv2:{n:"Life Steal Amount",t:"unreal"},
  ipv3:{n:"Amount Is Raw Value",t:"bool"},
  irc2:{n:"Restored Life",t:"int"},
  irc3:{n:"Restored Mana (-1 for current)",t:"int"},
  Ircd:{n:"Delay After Death (seconds)",t:"int"},
  Irec:{n:"Maximum Number of Units",t:"int"},
  irl1:{n:"Life Regenerated",t:"unreal"},
  irl2:{n:"Mana Regenerated",t:"unreal"},
  irl3:{n:"Allow When Full",t:"fullFlags"},
  irl4:{n:"No Target Required",t:"bool"},
  irl5:{n:"Dispel On Attack",t:"bool"},
  Isib:{n:"Sight Range Bonus",t:"int"},
  Isn1:{n:"Summon 1 - Amount",t:"int"},
  Isn2:{n:"Summon 2 - Amount",t:"int"},
  Ispi:{n:"Movement Speed Increase",t:"unreal"},
  isr1:{n:"Damage Bonus",t:"unreal"},
  isr2:{n:"Damage Reduction",t:"unreal"},
  Ist1:{n:"Summon 1 - Unit Type",t:"unitCode"},
  Ist2:{n:"Summon 2 - Unit Type",t:"unitCode"},
  Isx1:{n:"Attack Speed Increase",t:"unreal"},
  Itp2:{n:"Use Teleport Clustering",t:"bool"},
  Itpm:{n:"Maximum Number of Units",t:"int"},
  Ivam:{n:"Life Stolen Per Attack",t:"unreal"},
  Ivs1:{n:"Transition Time (seconds)",t:"unreal"},
  Ixpg:{n:"Experience Gained",t:"int"},
  Ixs1:{n:"Damage To Summoned Units",t:"unreal"},
  Ixs2:{n:"Magic Damage Reduction",t:"unreal"},
  liq1:{n:"Extra Damage Per Second",t:"unreal"},
  liq2:{n:"Movement Speed Reduction",t:"unreal"},
  liq3:{n:"Attack Speed Reduction",t:"unreal"},
  liq4:{n:"Repairs Allowed",t:"bool"},
  Lit1:{n:"Graphic Delay",t:"unreal"},
  Lit2:{n:"Graphic Duration",t:"unreal"},
  Loa1:{n:"Allowed Unit Type",t:"unitCode"},
  Lsh1:{n:"Damage per Second",t:"unreal"},
  Mbt1:{n:"Mana Gained",t:"unreal"},
  Mbt2:{n:"Hit Points Gained",t:"unreal"},
  Mbt3:{n:"Autocast Requirement",t:"unreal"},
  Mbt4:{n:"Water Height",t:"unreal"},
  Mbt5:{n:"Regenerate Only At Night",t:"bool"},
  mec1:{n:"Number of Units Created",t:"int"},
  mfl1:{n:"Unit - Damage Per Mana Point",t:"unreal"},
  mfl2:{n:"Hero - Damage Per Mana Point",t:"unreal"},
  mfl3:{n:"Unit - Maximum Damage",t:"unreal"},
  mfl4:{n:"Hero - Maximum Damage",t:"unreal"},
  mfl5:{n:"Damage Cooldown",t:"unreal"},
  mfl6:{n:"Caster Only Splash",t:"bool"},
  Mil1:{n:"Normal Form Unit",t:"unitCode"},
  Mil2:{n:"Alternate Form Unit",t:"unitCode"},
  mim1:{n:"Magic Damage Factor",t:"unreal"},
  Min1:{n:"Activation Delay",t:"unreal"},
  Min2:{n:"Invisibility Transition Time",t:"unreal"},
  mls1:{n:"Damage Per Second",t:"unreal"},
  Nab1:{n:"Movement Speed Reduction (%)",t:"unreal"},
  Nab2:{n:"Attack Speed Reduction (%)",t:"unreal"},
  Nab3:{n:"Armor Penalty",t:"int"},
  Nab4:{n:"Primary Damage",t:"unreal"},
  Nab5:{n:"Secondary Damage",t:"unreal"},
  Nab6:{n:"Damage Interval",t:"unreal"},
  Nba1:{n:"Damage Bonus",t:"unreal"},
  Nba2:{n:"Number of Summoned Units",t:"int"},
  Nba3:{n:"Summoned Unit Duration (seconds)",t:"unreal"},
  Nbau:{n:"Summoned Unit Type",t:"unitCode"},
  Nbf5:{n:"Damage Per Second",t:"unreal"},
  Nbr1:{n:"Damage Increase",t:"unreal"},
  nca1:{n:"Distributed Damage Factor",t:"unreal"},
  Nch1:{n:"Maximum Creep Level",t:"int"},
  Ncl1:{n:"Follow Through Time",t:"unreal"},
  Ncl2:{n:"Target Type",t:"channelType"},
  Ncl3:{n:"Options",t:"channelFlags"},
  Ncl4:{n:"Art Duration",t:"unreal"},
  Ncl5:{n:"Disable Other Abilities",t:"bool"},
  Ncl6:{n:"Base Order ID",t:"orderString"},
  Ncr5:{n:"Move Speed Bonus (Info Panel Only)",t:"unreal"},
  Ncr6:{n:"Attack Speed Bonus (Info Panel Only)",t:"unreal"},
  Ncs1:{n:"Damage Amount",t:"unreal"},
  Ncs2:{n:"Damage Interval",t:"unreal"},
  Ncs3:{n:"Missile Count",t:"int"},
  Ncs4:{n:"Max Damage",t:"unreal"},
  Ncs5:{n:"Building Damage Factor",t:"unreal"},
  Ncs6:{n:"Effect Duration",t:"unreal"},
  Ndc1:{n:"Race to Convert",t:"unitRace"},
  Ndc2:{n:"Conversion Unit",t:"unitCode"},
  Nde1:{n:"Chance to Demolish",t:"unreal"},
  Nde2:{n:"Damage Multiplier (Buildings)",t:"unreal"},
  Nde3:{n:"Damage Multiplier (Units)",t:"unreal"},
  Nde4:{n:"Damage Multiplier (Heroes)",t:"unreal"},
  Ndo1:{n:"Damage Per Second",t:"unreal"},
  Ndo2:{n:"Number of Summoned Units",t:"int"},
  Ndo3:{n:"Summoned Unit Duration (seconds)",t:"unreal"},
  Ndou:{n:"Summoned Unit Type",t:"unitCode"},
  Ndp1:{n:"Spawned Units",t:"unitList"},
  Ndp2:{n:"Minimum Number of Units",t:"int"},
  Ndp3:{n:"Maximum Number of Units",t:"int"},
  Ndr1:{n:"Hit Points Drained",t:"unreal"},
  Ndr2:{n:"Mana Points Drained",t:"unreal"},
  Ndr3:{n:"Drain Interval (seconds)",t:"unreal"},
  Ndr4:{n:"Life Transferred Per Second",t:"unreal"},
  Ndr5:{n:"Mana Transferred Per Second",t:"unreal"},
  Ndr6:{n:"Bonus Life Factor",t:"unreal"},
  Ndr7:{n:"Bonus Life Decay",t:"unreal"},
  Ndr8:{n:"Bonus Mana Factor",t:"unreal"},
  Ndr9:{n:"Bonus Mana Decay",t:"unreal"},
  Ndt1:{n:"Gold Cost",t:"int"},
  Ndt2:{n:"Lumber Cost",t:"int"},
  Ndt3:{n:"Detection Type",t:"detectionType"},
  Nef1:{n:"Summoned Unit Types",t:"unitList"},
  Neg1:{n:"Move Speed Bonus",t:"unreal"},
  Neg2:{n:"Damage Bonus",t:"unreal"},
  Neg3:{n:"Ability Upgrade 1",t:"heroAbilityList"},
  Neg4:{n:"Ability Upgrade 2",t:"heroAbilityList"},
  Neg5:{n:"Ability Upgrade 3",t:"heroAbilityList"},
  Neg6:{n:"Ability Upgrade 4",t:"heroAbilityList"},
  Neu1:{n:"Activation Radius",t:"unreal"},
  Neu2:{n:"Interaction Type",t:"interactionFlags"},
  Neu3:{n:"Show Select Unit Button",t:"bool"},
  Neu4:{n:"Show Unit Indicator",t:"bool"},
  Nfd1:{n:"Graphic Delay",t:"unreal"},
  Nfd2:{n:"Graphic Duration",t:"unreal"},
  Nfd3:{n:"Damage",t:"unreal"},
  Nfy1:{n:"Spawn Interval",t:"unreal"},
  Nfy2:{n:"Leash Range",t:"unreal"},
  Nfyu:{n:"Spawn Unit ID",t:"unitCode"},
  Nhs6:{n:"Wave Count",t:"int"},
  Nic1:{n:"Bonus Damage Multiplier",t:"unreal"},
  Nic2:{n:"Death Damage Full Amount",t:"unreal"},
  Nic3:{n:"Death Damage Full Area",t:"unreal"},
  Nic4:{n:"Death Damage Half Amount",t:"unreal"},
  Nic5:{n:"Death Damage Half Area",t:"unreal"},
  Nic6:{n:"Death Damage Delay",t:"unreal"},
  Nlm2:{n:"Split Delay",t:"unreal"},
  Nlm3:{n:"Split Attack Count",t:"int"},
  Nlm4:{n:"Max Hitpoint Factor",t:"unreal"},
  Nlm5:{n:"Life Duration Split Bonus",t:"unreal"},
  Nlm6:{n:"Generation Count",t:"int"},
  Nmr1:{n:"Mana Drained per Second",t:"unreal"},
  Nms1:{n:"Mana per Hit Point",t:"unreal"},
  Nms2:{n:"Damage Absorbed (%)",t:"unreal"},
  Npa5:{n:"Summoned Unit Count",t:"int"},
  Npa6:{n:"Summoned Unit Duration",t:"unreal"},
  Npr1:{n:"Building Types Allowed",t:"pickFlags"},
  Nrc1:{n:"Ability for Unit Creation",t:"abilCode"},
  Nrc2:{n:"Number of Units Created",t:"int"},
  Nrg5:{n:"Strength Bonus",t:"int"},
  Nrg6:{n:"Defense Bonus",t:"int"},
  Nsa1:{n:"Building Types Allowed",t:"pickFlags"},
  Nsa2:{n:"Hero Regeneration Delay",t:"unreal"},
  Nsa3:{n:"Unit Regeneration Delay",t:"unreal"},
  Nsa4:{n:"Magic Damage Reduction",t:"unreal"},
  Nsa5:{n:"Hit Points Per Second",t:"unreal"},
  Nse1:{n:"Shield Cooldown Time",t:"unreal"},
  Nsi1:{n:"Attacks Prevented",t:"silenceFlags"},
  Nsi2:{n:"Chance To Miss (%)",t:"unreal"},
  Nsi3:{n:"Movement Speed Modifier",t:"unreal"},
  Nsi4:{n:"Attack Speed Modifier",t:"unreal"},
  Nsl1:{n:"Unit to Preserve",t:"unitCode"},
  Nso1:{n:"Damage Amount",t:"unreal"},
  Nso2:{n:"Damage Period",t:"unreal"},
  Nso3:{n:"Damage Penalty",t:"unreal"},
  Nso4:{n:"Movement Speed Reduction (%)",t:"unreal"},
  Nso5:{n:"Attack Speed Reduction (%)",t:"unreal"},
  Nsp1:{n:"Gold Cost per Structure",t:"int"},
  Nsp2:{n:"Lumber Cost per Use",t:"int"},
  Nsp3:{n:"Detection Type",t:"detectionType"},
  Nst1:{n:"Beasts Per Second",t:"int"},
  Nst2:{n:"Beast Collision Radius",t:"unreal"},
  Nst3:{n:"Damage Amount",t:"unreal"},
  Nst4:{n:"Damage Radius",t:"unreal"},
  Nst5:{n:"Damage Delay",t:"unreal"},
  Nsy1:{n:"Spawn Interval",t:"unreal"},
  Nsy2:{n:"Spawn Unit ID",t:"unitCode"},
  Nsy3:{n:"Spawn Unit Duration",t:"unreal"},
  Nsy4:{n:"Spawn Unit Offset",t:"unreal"},
  Nsy5:{n:"Leash Range",t:"unreal"},
  Nsyu:{n:"Factory Unit ID",t:"unitCode"},
  Ntm1:{n:"Gold Cost Factor",t:"unreal"},
  Ntm2:{n:"Lumber Cost Factor",t:"unreal"},
  Ntm3:{n:"Max Creep Level",t:"int"},
  Ntm4:{n:"Allow Bounty",t:"bool"},
  Ntou:{n:"Summoned Unit Type",t:"unitCode"},
  Nvc1:{n:"Rock Ring Count",t:"int"},
  Nvc2:{n:"Wave Count",t:"int"},
  Nvc3:{n:"Wave Interval",t:"unreal"},
  Nvc4:{n:"Building Damage Factor",t:"unreal"},
  Nvc5:{n:"Full Damage Amount",t:"unreal"},
  Nvc6:{n:"Half Damage Factor",t:"unreal"},
  Nvcu:{n:"Destructible ID",t:"unitCode"},
  Oae1:{n:"Movement Speed Increase (%)",t:"unreal"},
  Oae2:{n:"Attack Speed Increase (%)",t:"unreal"},
  Oar1:{n:"Amount of Hit Points Regenerated",t:"unreal"},
  Oar2:{n:"Percentage",t:"bool"},
  Ocl1:{n:"Damage per Target",t:"unreal"},
  Ocl2:{n:"Number of Targets Hit",t:"int"},
  Ocl3:{n:"Damage Reduction per Target",t:"unreal"},
  Ocr1:{n:"Chance to Critical Strike",t:"unreal"},
  Ocr2:{n:"Damage Multiplier",t:"unreal"},
  Ocr3:{n:"Damage Bonus",t:"unreal"},
  Ocr4:{n:"Chance to Evade",t:"unreal"},
  Ocr5:{n:"Never Miss",t:"bool"},
  Oeq1:{n:"Effect Delay",t:"unreal"},
  Oeq2:{n:"Damage per Second to Buildings",t:"unreal"},
  Oeq3:{n:"Units Slowed (%)",t:"unreal"},
  Oeq4:{n:"Final Area",t:"unreal"},
  Ofs1:{n:"Detection Type",t:"detectionType"},
  Omi1:{n:"Number of Images",t:"int"},
  Omi2:{n:"Damage Dealt (%)",t:"unreal"},
  Omi3:{n:"Damage Taken (%)",t:"unreal"},
  Omi4:{n:"Animation Delay",t:"unreal"},
  Ore1:{n:"Reincarnation Delay",t:"unreal"},
  Osf1:{n:"Summoned Unit",t:"unitCode"},
  Osf2:{n:"Number of Summoned Units",t:"int"},
  Osh1:{n:"Damage",t:"unreal"},
  Osh2:{n:"Maximum Damage",t:"unreal"},
  Osh3:{n:"Distance",t:"unreal"},
  Osh4:{n:"Final Area",t:"unreal"},
  Owk1:{n:"Transition Time",t:"unreal"},
  Owk2:{n:"Movement Speed Increase (%)",t:"unreal"},
  Owk3:{n:"Backstab Damage",t:"unreal"},
  Owk4:{n:"Backstab Damage",t:"bool"},
  Oww1:{n:"Damage Per Second",t:"unreal"},
  Oww2:{n:"Magic Damage Reduction",t:"unreal"},
  Ply1:{n:"Maximum Creep Level",t:"int"},
  Ply2:{n:"Morph Units - Ground",t:"unitList"},
  Ply3:{n:"Morph Units - Air",t:"unitList"},
  Ply4:{n:"Morph Units - Amphibious",t:"unitList"},
  Ply5:{n:"Morph Units - Water",t:"unitList"},
  Poa1:{n:"Extra Damage",t:"unreal"},
  Poa2:{n:"Damage per Second",t:"unreal"},
  Poa3:{n:"Attack Speed Factor",t:"unreal"},
  Poa4:{n:"Movement Speed Factor",t:"unreal"},
  Poa5:{n:"Stacking Type",t:"stackFlags"},
  Poi1:{n:"Damage per Second",t:"unreal"},
  Poi2:{n:"Attack Speed Factor",t:"unreal"},
  Poi3:{n:"Movement Speed Factor",t:"unreal"},
  Poi4:{n:"Stacking Type",t:"stackFlags"},
  Pos1:{n:"Maximum Creep Level",t:"int"},
  Pos2:{n:"Damage Amplification",t:"unreal"},
  Pos3:{n:"Target Is Invulnerable",t:"bool"},
  Pos4:{n:"Target Is Magic Immune",t:"bool"},
  Prg1:{n:"Movement Update Frequency",t:"int"},
  Prg2:{n:"Attack Update Frequency",t:"int"},
  Prg3:{n:"Summoned Unit Damage",t:"unreal"},
  Prg4:{n:"Unit Pause Duration",t:"unreal"},
  Prg5:{n:"Hero Pause Duration",t:"unreal"},
  Prg6:{n:"Mana Loss",t:"int"},
  pxf1:{n:"Initial Damage",t:"unreal"},
  pxf2:{n:"Damage Per Second",t:"unreal"},
  Rai1:{n:"Units Summoned (Type One)",t:"int"},
  Rai2:{n:"Units Summoned (Type Two)",t:"int"},
  Rai3:{n:"Unit Type One",t:"unitCode"},
  Rai4:{n:"Unit Type Two",t:"unitCode"},
  Raiu:{n:"Unit Type For Limit Check",t:"unitCode"},
  Rej1:{n:"Hit Points Gained",t:"unreal"},
  Rej2:{n:"Mana Points Gained",t:"unreal"},
  Rej3:{n:"Allow When Full",t:"fullFlags"},
  Rej4:{n:"No Target Required",t:"bool"},
  Rep1:{n:"Repair Cost Ratio",t:"unreal"},
  Rep2:{n:"Repair Time Ratio",t:"unreal"},
  Rep3:{n:"Powerbuild Cost",t:"unreal"},
  Rep4:{n:"Powerbuild Rate",t:"unreal"},
  Rep5:{n:"Naval Range Bonus",t:"unreal"},
  Roa1:{n:"Damage Increase (%)",t:"unreal"},
  Roa2:{n:"Defense Increase",t:"int"},
  Roa3:{n:"Life Regeneration Rate",t:"unreal"},
  Roa4:{n:"Mana Regen",t:"unreal"},
  Roa5:{n:"Prefer Hostiles",t:"bool"},
  Roa6:{n:"Prefer Friendlies",t:"bool"},
  Roa7:{n:"Max Units",t:"int"},
  Roo1:{n:"Rooted Weapons",t:"attackBits"},
  Roo2:{n:"Uprooted Weapons",t:"attackBits"},
  Roo3:{n:"Rooted Turning",t:"bool"},
  Roo4:{n:"Uprooted Defense Type",t:"defenseTypeInt"},
  Rpb3:{n:"Minimum Life Required",t:"unreal"},
  Rpb4:{n:"Minimum Mana Required",t:"unreal"},
  Rpb5:{n:"Maximum Units Charged To Caster",t:"int"},
  Rpb6:{n:"Maximum Units Affected",t:"int"},
  Rtn1:{n:"Accepts Gold",t:"bool"},
  Rtn2:{n:"Accepts Lumber",t:"bool"},
  Sal1:{n:"Salvage Cost Ratio",t:"unreal"},
  Sal2:{n:"Accumulation Step",t:"int"},
  Sds1:{n:"Building Damage Factor",t:"unreal"},
  Sds6:{n:"Explodes on Death",t:"bool"},
  Shm1:{n:"Fade Duration",t:"unreal"},
  Shm2:{n:"Day/Night Duration",t:"unreal"},
  Shm3:{n:"Action Duration",t:"unreal"},
  sla1:{n:"Sleep Once",t:"bool"},
  sla2:{n:"Allow On Any Player Slot",t:"bool"},
  Slo1:{n:"Movement Speed Factor",t:"unreal"},
  Slo2:{n:"Attack Speed Factor",t:"unreal"},
  Slo3:{n:"Always Autocast",t:"bool"},
  Sod1:{n:"Number of Units",t:"int"},
  Sod2:{n:"Unit Type",t:"unitCode"},
  Spa1:{n:"Spider Capacity",t:"int"},
  spb1:{n:"Spell List",t:"abilityList"},
  spb2:{n:"Shared Spell Cooldown",t:"bool"},
  spb3:{n:"Minimum Spells",t:"int"},
  spb4:{n:"Maximum Spells",t:"int"},
  spb5:{n:"Base Order ID",t:"orderString"},
  spl1:{n:"Distributed Damage Factor",t:"unreal"},
  spl2:{n:"Maximum Number of Targets",t:"int"},
  Spo1:{n:"Damage Per Second",t:"unreal"},
  Spo2:{n:"Movement Speed Factor",t:"unreal"},
  Spo3:{n:"Attack Speed Factor",t:"unreal"},
  Spo4:{n:"Stacking Type",t:"stackFlags"},
  Ssk1:{n:"Chance to Reduce Damage (%)",t:"unreal"},
  Ssk2:{n:"Minimum Damage",t:"unreal"},
  Ssk3:{n:"Ignored Damage",t:"unreal"},
  Ssk4:{n:"Include Ranged Damage",t:"bool"},
  Ssk5:{n:"Include Melee Damage",t:"bool"},
  Sta1:{n:"Activation Delay",t:"unreal"},
  Sta2:{n:"Detection Radius",t:"unreal"},
  Sta3:{n:"Detonation Radius",t:"unreal"},
  Sta4:{n:"Stun Duration",t:"unreal"},
  Stau:{n:"Ward Unit Type",t:"unitCode"},
  Tau1:{n:"Prefer Hostiles",t:"int"},
  Tau2:{n:"Prefer Friendlies",t:"int"},
  Tau3:{n:"Max Units",t:"int"},
  Tdg1:{n:"Damage Per Second",t:"unreal"},
  Tdg2:{n:"Medium Damage Radius",t:"unreal"},
  Tdg3:{n:"Medium Damage Per Second",t:"unreal"},
  Tdg4:{n:"Small Damage Radius",t:"unreal"},
  Tdg5:{n:"Small Damage Per Second",t:"unreal"},
  tpi1:{n:"Required Unit Type",t:"unitCode"},
  tpi2:{n:"Converted Unit Type",t:"unitCode"},
  Tsp1:{n:"Air Time (seconds)",t:"unreal"},
  Tsp2:{n:"Minimum Hit Interval (seconds)",t:"unreal"},
  Uan1:{n:"Number of Corpses Raised",t:"int"},
  Uan3:{n:"Inherit Upgrades",t:"bool"},
  Uau1:{n:"Movement Speed Increase (%)",t:"unreal"},
  Uau2:{n:"Life Regeneration Increase (%)",t:"unreal"},
  Uau3:{n:"Percent Bonus",t:"bool"},
  Uav1:{n:"Attack Damage Stolen (%)",t:"unreal"},
  Ucb5:{n:"Max Units Summoned",t:"int"},
  Ucb6:{n:"Kill On Caster Death",t:"bool"},
  Uco5:{n:"Max Damage",t:"unreal"},
  Uco6:{n:"Move Speed Bonus",t:"unreal"},
  Ucs3:{n:"Distance",t:"unreal"},
  Ucs4:{n:"Final Area",t:"unreal"},
  Udc1:{n:"Amount Healed/Damaged",t:"unreal"},
  Udd1:{n:"Max Life Drained per Second (%)",t:"unreal"},
  Udd2:{n:"Building Reduction",t:"unreal"},
  Udp3:{n:"Mana Conversion As Percent",t:"bool"},
  Udp4:{n:"Life Conversion As Percent",t:"bool"},
  Udp5:{n:"Leave Target Alive",t:"bool"},
  Uds1:{n:"Maximum Units",t:"int"},
  Uds2:{n:"Casting Delay (seconds)",t:"unreal"},
  Ufa1:{n:"Armor Duration",t:"unreal"},
  Ufa2:{n:"Armor Bonus",t:"unreal"},
  Ufn1:{n:"Area of Effect Damage",t:"unreal"},
  Ufn2:{n:"Specific Target Damage",t:"unreal"},
  Uhf1:{n:"Attack Speed Bonus (%)",t:"unreal"},
  Uhf2:{n:"Damage per Second",t:"unreal"},
  Uim1:{n:"Wave Distance",t:"unreal"},
  Uim2:{n:"Wave Time (seconds)",t:"unreal"},
  Uim3:{n:"Damage Dealt",t:"unreal"},
  Uim4:{n:"Air Time (seconds)",t:"unreal"},
  Uin1:{n:"Damage",t:"unreal"},
  Uin2:{n:"Duration",t:"unreal"},
  Uin3:{n:"Impact Delay",t:"unreal"},
  Uin4:{n:"Summoned Unit",t:"unitCode"},
  Uls1:{n:"Number of Swarm Units",t:"int"},
  Uls2:{n:"Unit Release Interval (seconds)",t:"unreal"},
  Uls3:{n:"Max Swarm Units Per Target",t:"int"},
  Uls4:{n:"Damage Return Factor",t:"unreal"},
  Uls5:{n:"Damage Return Threshold",t:"unreal"},
  Ulsu:{n:"Swarm Unit Type",t:"unitCode"},
  Usl1:{n:"Stun Duration",t:"unreal"},
  Uts1:{n:"Returned Damage Factor",t:"unreal"},
  Uts2:{n:"Received Damage Factor",t:"unreal"},
  Uts3:{n:"Defense Bonus",t:"unreal"},
  War1:{n:"Chance to Stomp (%)",t:"unreal"},
  War2:{n:"Damage Dealt",t:"unreal"},
  War3:{n:"Full Damage Radius",t:"unreal"},
  War4:{n:"Half Damage Radius",t:"unreal"},
  Wha1:{n:"Lumber per Interval",t:"unreal"},
  Wha2:{n:"Intervals Before Changing Trees",t:"int"},
  Wha3:{n:"Art Attachment Height",t:"unreal"},
  Wrp1:{n:"Teleport Area Width",t:"unreal"},
  Wrp2:{n:"Teleport Area Height",t:"unreal"},
  Wrs1:{n:"Damage",t:"unreal"},
  Wrs2:{n:"Terrain Deformation Amplitude",t:"unreal"},
  Wrs3:{n:"Terrain Deformation Duration (ms)",t:"int"},
  // -- Buffs --
  fart:{n:"Icon",t:"icon"},
  feat:{n:"Effect",t:"modelList"},
  feff:{n:"Is an Effect",t:"bool"},
  fefl:{n:"Effect Sound (Looping)",t:"soundLabel"},
  fefs:{n:"Effect Sound",t:"soundLabel"},
  feft:{n:"Effect Attachment Point",t:"stringList"},
  flig:{n:"Lightning",t:"lightningEffect"},
  fmac:{n:"Missile Arc",t:"unreal"},
  fmat:{n:"Missile Art",t:"modelList"},
  fmho:{n:"Missile Homing Enabled",t:"bool"},
  fmsp:{n:"Missile Speed",t:"int"},
  fnam:{n:"Name (Editor Only)",t:"string"},
  fnsf:{n:"Editor Suffix",t:"string"},
  frac:{n:"Race",t:"unitRace"},
  fsat:{n:"Special",t:"modelList"},
  fspd:{n:"Required Spell Detail",t:"spellDetail"},
  fspt:{n:"Special Attachment Point",t:"stringList"},
  fta0:{n:"Target Attachment Point 1",t:"stringList"},
  fta1:{n:"Target Attachment Point 2",t:"stringList"},
  fta2:{n:"Target Attachment Point 3",t:"stringList"},
  fta3:{n:"Target Attachment Point 4",t:"stringList"},
  fta4:{n:"Target Attachment Point 5",t:"stringList"},
  fta5:{n:"Target Attachment Point 6",t:"stringList"},
  ftac:{n:"Target Attachments",t:"int"},
  ftat:{n:"Target",t:"modelList"},
  ftip:{n:"Tooltip",t:"string"},
  fube:{n:"Tooltip - Extended",t:"string"},
  // -- Destructables --
  barm:{n:"Armor Type",t:"armorType"},
  bbut:{n:"Build Time",t:"int"},
  bcat:{n:"Category",t:"destructableCategory"},
  bclh:{n:"Cliff Height",t:"int"},
  bcpd:{n:"Show Dead Version in Palette",t:"bool"},
  bcpr:{n:"Can Place Random Scale",t:"bool"},
  bdsn:{n:"Death",t:"soundLabel"},
  bfil:{n:"Model File",t:"model"},
  bflh:{n:"Fly-Over Height",t:"unreal"},
  bflo:{n:"Fat Line of Sight",t:"bool"},
  bfra:{n:"Fog Radius",t:"unreal"},
  bfvi:{n:"Fog Visibility",t:"bool"},
  bfxr:{n:"Fixed Rotation",t:"unreal"},
  bgpm:{n:"Model File - Portrait",t:"model"},
  bgsc:{n:"Selection Size - Game",t:"real"},
  bgse:{n:"Selectable In Game",t:"bool"},
  bhps:{n:"Hit Points",t:"unreal"},
  blit:{n:"Model File - Has Lightweight Model",t:"bool"},
  bmap:{n:"Maximum Pitch Angle (degrees)",t:"unreal"},
  bmar:{n:"Max Roll Angle (degrees)",t:"unreal"},
  bmas:{n:"Maximum Scale",t:"unreal"},
  bmis:{n:"Minimum Scale",t:"unreal"},
  bmmb:{n:"Minimap Color 3 (Blue)",t:"int"},
  bmmg:{n:"Minimap Color 2 (Green)",t:"int"},
  bmmr:{n:"Minimap Color 1 (Red)",t:"int"},
  bnam:{n:"Name",t:"string"},
  boch:{n:"Occlusion Height",t:"unreal"},
  bonc:{n:"Placeable on Cliffs",t:"bool"},
  bonw:{n:"Placeable on Water",t:"bool"},
  bptd:{n:"Pathing Texture (Dead)",t:"pathingTexture"},
  bptx:{n:"Pathing Texture",t:"pathingTexture"},
  brad:{n:"Elevation Sample Radius",t:"unreal"},
  breg:{n:"Repair Gold Cost",t:"int"},
  brel:{n:"Repair Lumber Cost",t:"int"},
  bret:{n:"Repair Time",t:"int"},
  bsel:{n:"Selection Size - Editor",t:"unreal"},
  bshd:{n:"Shadow",t:"shadowTexture"},
  bsmm:{n:"Minimap - Show",t:"bool"},
  bsuf:{n:"Editor Suffix",t:"string"},
  btar:{n:"Targeted As",t:"targetList"},
  btil:{n:"Tilesets",t:"tilesetList"},
  btsp:{n:"Has Tileset Specific Data",t:"bool"},
  btxf:{n:"Replaceable Texture File",t:"texture"},
  btxi:{n:"Replaceable Texture ID",t:"int"},
  buch:{n:"Show Helper Object for Selection",t:"bool"},
  bumm:{n:"Minimap - Use Custom Color",t:"bool"},
  busr:{n:"On User-Specified List",t:"bool"},
  bvar:{n:"Model File - Variations",t:"int"},
  bvcb:{n:"Tinting Color 3 (Blue)",t:"int"},
  bvcg:{n:"Tinting Color 2 (Green)",t:"int"},
  bvcr:{n:"Tinting Color 1 (Red)",t:"int"},
  bwal:{n:"Is Walkable",t:"bool"},
  // -- Doodads --
  danf:{n:"Animate in Fog",t:"bool"},
  dcat:{n:"Category",t:"doodadCategory"},
  dcpr:{n:"Can Place Random Scale",t:"bool"},
  ddes:{n:"Default Scale",t:"unreal"},
  dfil:{n:"Model File",t:"model"},
  dflt:{n:"Floats",t:"bool"},
  dfxr:{n:"Fixed Rotation",t:"unreal"},
  dimc:{n:"Ignore Model Clicks",t:"bool"},
  dmap:{n:"Maximum Pitch Angle (degrees)",t:"unreal"},
  dmar:{n:"Max Roll Angle (degrees)",t:"unreal"},
  dmas:{n:"Maximum Scale",t:"unreal"},
  dmis:{n:"Minimum Scale",t:"unreal"},
  dmmb:{n:"Minimap Color 3 (Blue)",t:"int"},
  dmmg:{n:"Minimap Color 2 (Green)",t:"int"},
  dmmr:{n:"Minimap Color 1 (Red)",t:"int"},
  dnam:{n:"Name",t:"string"},
  donc:{n:"Placeable on Cliffs",t:"bool"},
  donw:{n:"Placeable on Water",t:"bool"},
  dptx:{n:"Pathing Texture",t:"pathingTexture"},
  dsel:{n:"Selection Size",t:"unreal"},
  dshd:{n:"Has a Shadow",t:"bool"},
  dshf:{n:"Show in Fog",t:"bool"},
  dsmm:{n:"Minimap - Show",t:"bool"},
  dsnd:{n:"Looping Sound",t:"soundLabel"},
  dtil:{n:"Tilesets",t:"tilesetList"},
  dtsp:{n:"Has Tileset Specific Data",t:"bool"},
  duch:{n:"Use Click Helper",t:"bool"},
  dumc:{n:"Minimap - Use Custom Color",t:"bool"},
  dusr:{n:"On User-Specified List",t:"bool"},
  dvar:{n:"Variations",t:"int"},
  dvb1:{n:"Tinting Color 3 (Blue)",t:"int"},
  dvg1:{n:"Tinting Color 2 (Green)",t:"int"},
  dvis:{n:"Visibility Radius",t:"unreal"},
  dvr1:{n:"Tinting Color 1 (Red)",t:"int"},
  dwlk:{n:"Walkable",t:"bool"},
  // -- Upgrades --
  gar1:{n:"Icon",t:"icon"},
  gba1:{n:"Effect 1 - %s",t:"unreal"},
  gba2:{n:"Effect 2 - %s",t:"unreal"},
  gba3:{n:"Effect 3 - %s",t:"unreal"},
  gba4:{n:"Effect 4 - %s",t:"unreal"},
  gbpx:{n:"Button Position (X)",t:"int"},
  gbpy:{n:"Button Position (Y)",t:"int"},
  gcls:{n:"Class",t:"upgradeClass"},
  gco1:{n:"Effect 1 - %s",t:"string"},
  gco2:{n:"Effect 2 - %s",t:"string"},
  gco3:{n:"Effect 3 - %s",t:"string"},
  gco4:{n:"Effect 4 - %s",t:"string"},
  gef1:{n:"Effect 1",t:"upgradeEffect"},
  gef2:{n:"Effect 2",t:"upgradeEffect"},
  gef3:{n:"Effect 3",t:"upgradeEffect"},
  gef4:{n:"Effect 4",t:"upgradeEffect"},
  gglb:{n:"Gold Base",t:"int"},
  gglm:{n:"Gold Increment",t:"int"},
  ghk1:{n:"Hotkey",t:"char"},
  ginh:{n:"Transfer with Unit Ownership",t:"bool"},
  glmb:{n:"Lumber Base",t:"int"},
  glmm:{n:"Lumber Increment",t:"int"},
  glob:{n:"Applies to All Units",t:"bool"},
  glvl:{n:"Levels",t:"int"},
  gmo1:{n:"Effect 1 - %s",t:"unreal"},
  gmo2:{n:"Effect 2 - %s",t:"unreal"},
  gmo3:{n:"Effect 3 - %s",t:"unreal"},
  gmo4:{n:"Effect 4 - %s",t:"unreal"},
  gnam:{n:"Name",t:"string"},
  gnsf:{n:"Editor Suffix",t:"string"},
  grac:{n:"Race",t:"unitRace"},
  greq:{n:"Requirements",t:"techList"},
  grqc:{n:"Requirements - Levels",t:"intList"},
  gtib:{n:"Time Base",t:"int"},
  gtim:{n:"Time Increment",t:"int"},
  gtp1:{n:"Tooltip",t:"string"},
  gub1:{n:"Tooltip - Extended",t:"string"},
};


function fieldName(id) { return KNOWN[id]?.n || id; }

// ================================================================
// TYPE CONSTANTS
// ================================================================
const TYPE_INT    = 0;
const TYPE_REAL   = 1;
const TYPE_UNREAL = 2;
const TYPE_STRING = 3;
const TYPE_NAMES  = { 0:'int', 1:'real', 2:'unreal', 3:'string' };
const TYPE_IDS    = { int:0, real:1, unreal:2, string:3 };

// Object types that carry level + column per modification
const TYPES_WITH_LEVELS = new Set(['w3a','w3d','w3q']);

// ================================================================
// META-TYPE RESOLUTION
//
// The binary format stores only int/real/unreal/string.
// KNOWN[fieldId].t carries a richer metadata type (e.g. "bool",
// "icon", "unitRace", "techList").  These helpers bridge the two.
// ================================================================

/** Return the metadata type for a field id, e.g. "bool", "icon". Falls back to wire type. */
function getMetaType(fieldId) {
  return KNOWN[fieldId]?.t || null;
}

/** Map a metadata type to the binary wire-type name used by the format. */
function getWireType(metaType) {
  if (!metaType) return 'string';
  if (metaType === 'bool' || metaType === 'int') return 'int';
  if (metaType === 'real')   return 'real';
  if (metaType === 'unreal') return 'unreal';
  return 'string';  // icon, model, unitRace, techList, etc.
}

/**
 * Dropdown / enum option lists keyed by metadata type.
 * Each entry is an array of { value, label } objects.
 *
 * To add a dropdown for a new type later, just add an entry here:
 *   META_TYPE_OPTIONS['unitRace'] = [
 *     { value:'human', label:'Human' },
 *     { value:'orc',   label:'Orc'   },
 *     ...
 *   ];
 */
const META_TYPE_OPTIONS = {
  bool: [
    { value: '1', label: 'True'  },
    { value: '0', label: 'False' }
  ],
  unitRace: [
    { value: 'commoner',  label: 'Commoner'  },
    { value: 'creeps',    label: 'Creeps'    },
    { value: 'critters',  label: 'Critters'  },
    { value: 'demon',     label: 'Demon'     },
    { value: 'human',     label: 'Human'     },
    { value: 'naga',      label: 'Naga'      },
    { value: 'nightelf',  label: 'Nightelf'  },
    { value: 'orc',       label: 'Orc'       },
    { value: 'other',     label: 'Other'     },
    { value: 'undead',    label: 'Undead'    },
    { value: 'unknown',   label: 'Unknown'   }
  ],
  defenseType: [
    { value: 'normal', label: 'Normal' },
    { value: 'small', label: 'Small' },
    { value: 'medium', label: 'Medium' },
    { value: 'large', label: 'Large' },
    { value: 'fort', label: 'Fortified' },
    { value: 'hero', label: 'Hero' },
    { value: 'divine', label: 'Divine' },
    { value: 'none', label: 'Unarmored' }
  ],
  moveType: [
    { value: 'foot', label: 'Foot' },
    { value: 'horse', label: 'Horse' },
    { value: 'fly', label: 'Fly' },
    { value: 'hover', label: 'Hover' },
    { value: 'float', label: 'Float' },
    { value: 'amph', label: 'Amphipic' }
  ],
  weaponType: [
    { value: 'normal', label: 'Normal' },
    { value: 'instant', label: 'Instant' },
    { value: 'artillery', label: 'Artillery' },
    { value: 'aline', label: 'ArtilleryLine' },
    { value: 'missile', label: 'Missile' },
    { value: 'msplash', label: 'MissileSplash' },
    { value: 'mbounce', label: 'MissileBounce' },
    { value: 'mline', label: 'MissileLine' },
    { value: '_', label: 'None' }
  ],
  combatSound: [
    { value: 'Nothing', label: 'Nothing' },
    { value: 'AxeMediumChop', label: 'AxeMediumChop' },
    { value: 'MetalHeavyBash', label: 'MetalHeavyBash' },
    { value: 'MetalHeavyChop', label: 'MetalHeavyChop' },
    { value: 'MetalHeavySlice', label: 'MetalHeavySlice' },
    { value: 'MetalLightChop', label: 'MetalLightChop' },
    { value: 'MetalLightSlice', label: 'MetalLightSlice' },
    { value: 'MetalMediumBash', label: 'MetalMediumBash' },
    { value: 'MetalMediumChop', label: 'MetalMediumChop' },
    { value: 'MetalMediumSlice', label: 'MetalMediumSlice' },
    { value: 'RockHeavyBash', label: 'RockHeavyBash' },
    { value: 'WoodHeavyBash', label: 'WoodHeavyBash' },
    { value: 'WoodLightBash', label: 'WoodLightBash' },
    { value: 'WoodMediumBash', label: 'WoodMediumBash' }
  ],
  attackType: [
    { value: 'unknown', label: 'Unknown' },
    { value: 'normal', label: 'Normal' },
    { value: 'pierce', label: 'Pierce' },
    { value: 'siege', label: 'Siege' },
    { value: 'spells', label: 'Spells' },
    { value: 'chaos', label: 'Chaos' },
    { value: 'magic', label: 'Magic' },
    { value: 'hero', label: 'Hero' }
  ],
  armorType: [
    { value: 'Ethereal', label: 'Ethereal' },
    { value: 'Flesh', label: 'Flesh' },
    { value: 'Wood', label: 'Wood' },
    { value: 'Stone', label: 'Stone' },
    { value: 'Metal', label: 'Metal' }
  ]
};

// Extension info
const EXT_INFO = {
  w3t: { label:'Items',          hasLevels:false },
  w3a: { label:'Abilities',      hasLevels:true  },
  w3u: { label:'Units',          hasLevels:false },
  w3b: { label:'Destructables',  hasLevels:false },
  w3h: { label:'Buffs',          hasLevels:false },
  w3d: { label:'Doodads',        hasLevels:true  },
  w3q: { label:'Upgrades',       hasLevels:true  },
};

// Column sort priority
const ITEM_PRI = ['unam','unsf','iabi','igol','ilum','ihtp','iuse','isto','ilev','ilvo','icla','iarm','imvt','irnw','ircv','istr','isst','isit','ista','iper','ipri','iicd','icid','iusa','imap','ican','ureq','urqa','iprn','isel','idrp','idro','ipaw','ipow','imor','ubpx','ubpy','isca','isch','issc','iclr','iclg','iclb','utip','utub','itip','iube','itp2','ides','uhot','iico','ifil','uani','uico','umdl','usnd','ufoo','usca','urac','ucls','uhpr','umvs'];
const ABIL_PRI = ['anam','alev','aart','arar','ahky','amcs','acdn','adur','ahdu','aran','aare','acas','atar','areq','arqa','achd','aher','aite','apri','arac','abuf','aeff','atp1','aub1','aret','arut','aut1','auu1','auhk','ansf','aord','aoro','aorf','aoru','aeat','acat','atat','asat','alig','alat','aani','aaea','abpx','abpy','aubx','auby','arpx','arpy','acap','aca1','acac','aspt','ata0','ata1','ata2','ata3','ata4','ata5','atac','auar','amac','amat','amho','amsp','aefs','aefl','ausk','Rtn1','Rtn2','Ocl1','Ocl2','Ocl3','Ocl4','Ocl5','Ocl6','Ocl7','Ocl8','Hfa1','Had1','Eim1','Efk1','Ear1','Nms1','Esf1','Esf2'];
const UNIT_PRI = ['unam','unsf','uico','umdl','usnd','urac','ucls','utyp','ulev','ugol','ulum','ufoo','uhpm','uhpr','uhrt','udef','udty','uarm','umvs','umvt','umvh','ustr','ustp','uint','uinp','uagp','umpi','umpm','umpr','ua1t','ua1b','ua1f','ua1d','ua1c','ua1r','ua1g','ua1m','ua1w','ua2t','ua2b','ua2f','ua2c','ua2w','uabi','uhab','udaa','utra','ubui','ures','upgr','uupt','umki','useu','usei','ureq','urqa','upar','ufma','upap','usca','ussc','uclr','uclg','uclb','usin','usid','ushu','ussi','uani','utip','utub','utpr','uawt','upro','uhot','uaen','udea','udup','ubld','usrg','usma','usst','ugor','ulur','uble','ucpt','ucbs','urtm','uobs','uubs','upat','ubdd','ubpx','ubpy'];
const BUFF_PRI = ['fnam','fnsf','ftip','fube','fart','feat','feft','ftat','fta0','fta1','fta2','fta3','fta4','fta5','ftac','fsat','fspt','flig','fmac','fmat','fmho','fmsp','fspd','fefs','fefl','feff','frac'];
const UPGR_PRI = ['glvl','gnam','gnsf','gar1','ghk1','gtp1','gub1','grac','gcls','glob','ginh','gglb','gglm','glmb','glmm','gtib','gtim','gef1','gba1','gco1','gmo1','gef2','gba2','gco2','gmo2','gef3','gba3','gco3','gmo3','gef4','gba4','gco4','gmo4','greq','grqc','gbpx','gbpy'];
const DEST_PRI = ['bnam','bsuf','bfil','bgpm','bcat','btil','btsp','bhps','barm','blit','bsel','bgsc','bgse','bmmr','bmmg','bmmb','bsmm','bumm','bvcr','bvcg','bvcb','boch','bflh','bflo','bfra','bfvi','bfxr','bmap','bmar','bmas','bmis','bcpr','bonc','bonw','bwal','bptx','bptd','bshd','btar','btxf','btxi','brad','breg','brel','bret','bbut','bdsn','buch','busr','bcpd','bvar','bclh'];
const DOOD_PRI = ['dnam','dvar','dfil','dcat','dtil','dtsp','ddes','dmas','dmis','dcpr','dfxr','dmap','dmar','dsel','dmmr','dmmg','dmmb','dsmm','dumc','dvr1','dvg1','dvb1','dvis','dshd','dshf','danf','dflt','donc','donw','dwlk','dptx','dimc','dsnd','duch','dusr'];

// ================================================================
// BINARY READER  (browser ArrayBuffer)
//
// Reference: WC3MapTranslator W3Buffer / ObjectsTranslator.ts
// All multi-byte values are little-endian.
// Strings are null-terminated UTF-8.
// IDs are 4 raw ASCII bytes (or 0x00000000 for "none").
// ================================================================
class BinaryReader {
  constructor(arrayBuffer) {
    this.buf = new DataView(arrayBuffer);
    this.u8  = new Uint8Array(arrayBuffer);
    this.pos = 0;
    this.len = arrayBuffer.byteLength;
  }
  hasMore()    { return this.pos < this.len; }
  readInt32()  { const v = this.buf.getInt32(this.pos, true);  this.pos += 4; return v; }
  readUInt32() { const v = this.buf.getUint32(this.pos, true); this.pos += 4; return v; }
  readFloat32(){
    const v = this.buf.getFloat32(this.pos, true);
    this.pos += 4;
    return v;
  }
  readId() {
    const a = this.u8[this.pos], b = this.u8[this.pos+1],
          c = this.u8[this.pos+2], d = this.u8[this.pos+3];
    this.pos += 4;
    if (a === 0 && b === 0 && c === 0 && d === 0) return '\0\0\0\0';
    return String.fromCharCode(a, b, c, d);
  }
  readString() {
    let end = this.pos;
    while (end < this.len && this.u8[end] !== 0) end++;
    const bytes = this.u8.subarray(this.pos, end);
    this.pos = end + 1;
    return new TextDecoder('utf-8').decode(bytes);
  }
}

// ================================================================
// BINARY WRITER  (browser ArrayBuffer)
//
// Builds a list of Uint8Array chunks, then concatenates into a Blob.
// ================================================================
class BinaryWriter {
  constructor() { this.parts = []; }
  writeInt32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setInt32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeUInt32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setUint32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeFloat32(v) {
    const b = new ArrayBuffer(4); new DataView(b).setFloat32(0, v, true);
    this.parts.push(new Uint8Array(b));
  }
  writeId(s) {
    const b = new Uint8Array(4);
    if (s && s !== '\0\0\0\0') {
      for (let i = 0; i < 4 && i < s.length; i++) b[i] = s.charCodeAt(i) & 0xFF;
    }
    this.parts.push(b);
  }
  writeString(s) {
    this.parts.push(new TextEncoder().encode(s));
    this.parts.push(new Uint8Array([0]));
  }
  toBlob() {
    return new Blob(this.parts, { type: 'application/octet-stream' });
  }
  toUint8Array() {
    let total = 0;
    for (const p of this.parts) total += p.byteLength;
    const out = new Uint8Array(total);
    let off = 0;
    for (const p of this.parts) { out.set(p, off); off += p.byteLength; }
    return out;
  }
}

// ================================================================
// PARSE BINARY -> editor state
//
// Binary layout per spec (https://github.com/stijnherfst/HiveWE/wiki/war3map(skin).w3*-Modifications):
//   uint32  format_version  (1, 2, or 3)
//   -- table (repeated 1 or 2 times, must check EOF) --
//   uint32  object_count
//   for each object:
//     char[4]  original_id
//     char[4]  modified_id   (0x00000000 for original table entries)
//     if format_version >= 3:
//       uint32  sets_count
//     else: sets_count = 1
//     for each set:
//       if format_version >= 3:
//         uint32  set_flag
//       uint32  modifications_count
//       for each modification:
//         char[4]  modification_id
//         uint32   variable_type (0=int, 1=real, 2=unreal, 3=string)
//         if optional_ints:
//           uint32 level_variation
//           uint32 data_pointer
//         value (int32 | float32 | float32 | c_string)
//         if format_version > 0:
//           char[4]  end_token
// ================================================================
function parseBinaryBuffer(arrayBuffer, ext) {
  const r = new BinaryReader(arrayBuffer);
  const version = r.readUInt32();
  // Per spec: .w3a and .w3q always have optional_ints;
  // .w3d (doodads) has optional_ints only when format_version > 0
  const hasLevels = (ext === 'w3a' || ext === 'w3q') || (ext === 'w3d' && version > 0);

  const objects = { original: [], custom: [] };

  for (const tableKey of ['original', 'custom']) {
    // Spec: second table may not exist — check for EOF
    if (!r.hasMore()) break;

    const count = r.readUInt32();
    for (let i = 0; i < count; i++) {
      const baseId   = r.readId();
      const customId = r.readId();

      // sets_count only exists in version >= 3
      const setsCount = (version >= 3) ? r.readUInt32() : 1;

      const obj = {
        base_id: baseId,
        custom_id: (customId !== '\0\0\0\0') ? customId : null,
        fields: [],
        _endTag: null
      };

      // Iterate over all sets (typically 1)
      for (let s = 0; s < setsCount; s++) {
        // set_flag only exists in version >= 3
        if (version >= 3) {
          r.readUInt32(); // set_flag (0 = default/all asset modes)
        }

        const modCount = r.readUInt32();

        for (let m = 0; m < modCount; m++) {
          const fieldId   = r.readId();
          const valueType = r.readUInt32();

          let level = 0, column = 0;
          if (hasLevels) {
            level  = r.readUInt32();
            column = r.readUInt32();
          }

          let value;
          if (valueType === TYPE_INT)         value = r.readInt32();
          else if (valueType === TYPE_REAL)   value = r.readFloat32();
          else if (valueType === TYPE_UNREAL) value = r.readFloat32();
          else if (valueType === TYPE_STRING) value = r.readString();
          else                                value = r.readInt32();    // fallback

          // end_token only exists when format_version > 0
          let endTag = null;
          if (version > 0) {
            endTag = r.readId();
          }
          if (m === 0 && obj._endTag === null) obj._endTag = endTag;

          const field = { id: fieldId, type: TYPE_NAMES[valueType] || String(valueType) };
          if (hasLevels) { field.level = level; field.column = column; }
          field.value = value;
          field.endTag = endTag; // per-field end tag for mixed-endtag objects
          obj.fields.push(field);
        }
      }
      objects[tableKey].push(obj);
    }
  }
  return { version, hasLevels, ext, objects };
}

// ================================================================
// BUILD BINARY from current editor state
//
// Reconstructs the end-tag per the WC3 spec:
//   original table entries -> end tag = base ID
//   custom   table entries -> end tag = 0x00000000
// ================================================================
function buildBinaryFromState(type) {
  const st = S[type]; if (!st) return null;
  syncDOM(type);

  const hasLevels = st.meta._hasLevels;
  const w = new BinaryWriter();
  w.writeUInt32(st.meta.version || 3);

  // Rebuild object lists from rows
  const tables = { original: [], custom: [] };

  if (!hasLevels) {
    for (const row of st.rows) {
      const obj = {
        base_id: row.bid, custom_id: row.cid || null,
        tbl: row.tbl, _endTag: row._endTag, fields: []
      };
      const ordered = orderedFieldIds(row, st.cols);
      for (const fid of ordered) {
        const cell = row.v[fid];
        if (!cell) continue;
        const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
        obj.fields.push({ id: fid, type: ftype, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
      }
      tables[row.tbl].push(obj);
    }
  } else {
    // Group rows by gid
    const groups = new Map();
    const groupOrder = [];
    for (const row of st.rows) {
      if (!groups.has(row.gid)) { groups.set(row.gid, []); groupOrder.push(row.gid); }
      groups.get(row.gid).push(row);
    }
    for (const gid of groupOrder) {
      const gRows = groups.get(gid);
      const first = gRows[0];
      const obj = {
        base_id: first.bid, custom_id: first.cid || null,
        tbl: first.tbl, _endTag: first._endTag, fields: []
      };

      const rowByLevel = {};
      for (const row of gRows) rowByLevel[row.lvl] = row;

      if (first._gfo && first._gfo.length > 0) {
        // Preserve original cross-level field order
        const used = new Set();
        for (const { id: fid, lvl } of first._gfo) {
          const key = fid + '@' + lvl;
          if (used.has(key)) continue;
          used.add(key);
          // Main-row-only fields were relocated to level 0 during ingestion;
          // try the original level first, then fall back to level 0
          let row = rowByLevel[lvl];
          let cell = row ? row.v[fid] : null;
          if (!cell && rowByLevel[0]) {
            row = rowByLevel[0];
            cell = row.v[fid];
          }
          if (!row || !cell) continue;
          const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
          // Write the original level, not the row's current level
          const writeLevel = cell._origLevel != null ? cell._origLevel : lvl;
          obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                            value: coerceVal(cell.val, ftype), endTag: cell.endTag });
        }
        // Append any NEW fields not in original order
        for (const row of gRows) {
          for (const c of st.cols) {
            const key = c.id + '@' + (row.v[c.id]?._origLevel != null ? row.v[c.id]._origLevel : row.lvl);
            if (used.has(key)) continue;
            const cell = row.v[c.id]; if (!cell) continue;
            used.add(key);
            const ftype = cell.type || c.type;
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: c.id, type: ftype, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
          }
        }
      } else {
        for (const row of gRows) {
          const ordered = orderedFieldIds(row, st.cols);
          for (const fid of ordered) {
            const cell = row.v[fid]; if (!cell) continue;
            const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: fid, type: ftype, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, ftype), endTag: cell.endTag });
          }
        }
      }
      tables[first.tbl].push(obj);
    }
  }

  const writeVersion = st.meta.version || 3;

  // Write both tables to binary
  for (const tableKey of ['original', 'custom']) {
    const objs = tables[tableKey];
    w.writeUInt32(objs.length);

    for (const obj of objs) {
      w.writeId(obj.base_id);
      w.writeId(obj.custom_id || '\0\0\0\0');

      // sets_count and set_flag only in version >= 3
      if (writeVersion >= 3) {
        w.writeUInt32(1); // sets_count: always 1
        w.writeUInt32(0); // set_flag: 0 = default (all asset modes)
      }

      w.writeUInt32(obj.fields.length);

      for (const field of obj.fields) {
        const vtype = TYPE_IDS[field.type] ?? 0;
        w.writeId(field.id);
        w.writeUInt32(vtype);

        if (hasLevels) {
          w.writeUInt32(field.level ?? 0);
          w.writeUInt32(field.column ?? 0);
        }

        if (vtype === TYPE_INT)          w.writeInt32(Number(field.value) | 0);
        else if (vtype === TYPE_REAL)    w.writeFloat32(Number(field.value));
        else if (vtype === TYPE_UNREAL)  w.writeFloat32(Number(field.value));
        else if (vtype === TYPE_STRING)  w.writeString(String(field.value));
        else                             w.writeInt32(Number(field.value) | 0);

        // end_token only when format_version > 0
        if (writeVersion > 0) {
          // Per spec: use 0 (safe default) or the object's custom/base ID
          const endTag = field.endTag != null ? field.endTag
            : (obj._endTag != null ? obj._endTag
              : '\0\0\0\0');
          w.writeId(endTag);
        }
      }
    }
  }

  return w;
}

// ================================================================
// EDITOR STATE
// ================================================================
// S[type] = { meta, rows[], cols[] }
//   meta  = { _format, _type, _hasLevels, version, _fileName }
//   row   = { gid, tbl, bid, cid, lvl, v:{fieldId:{val,type,col?}}, _fo:[], _gfo? }
//   col   = { id, name, type }
const S = { items: null, abilities: null, units: null, buffs: null, upgrades: null, destructables: null, doodads: null };
let activeTab = 'items';

/** Map file extension to editor tab name. */
const EXT_TO_TYPE = {
  w3t: 'items', w3a: 'abilities', w3u: 'units',
  w3h: 'buffs', w3q: 'upgrades', w3b: 'destructables', w3d: 'doodads'
};
function extToType(ext) { return EXT_TO_TYPE[ext] || null; }

/** Field ID that stores the level/variation count for each leveled type. */
const LEVEL_COUNT_FIELD = {
  abilities: 'alev',
  upgrades: 'glvl',
  doodads: 'dvar'
};

/** Fields that can ONLY be edited in the main (head) row, not in sub-rows. */
const MAIN_ROW_ONLY = {
  abilities: new Set([
    'aani','aaea','abpx','abpy','arpx','arpy','aubx','auby',
    'acat','acap','aca1','acac','aeat','aart','arar','auar',
    'alig','amac','amat','amho','amsp','asat','aspt','unsf',
    'atat','ata0','ata1','ata2','ata3','ata4','ata5','atac',
    'ausk','aefs','aefl','aher','aite','alsk','alev','apri',
    'arac','arlv','achd','areq','arqa','ansf','arhk','ahky',
    'auhk','anam','aoro','aorf','aoru','aord','aret','arut'
  ]),
  upgrades: new Set([
    'gbpx','gbpy','gef1','gef2','gef3','gef4',
    'glob','gcls','gglb','gglm','glvl','glmb','glmm',
    'grac','gtib','gtim','ginh'
  ])
};

/** For doodads, only these fields are editable in sub-rows (variations); all others are main-row-only. */
const SUB_ROW_EDITABLE = {
  doodads: new Set(['dvr1','dvg1','dvb1'])
};

/** Check whether a field should be read-only in sub-rows. */
function isMainRowOnly(type, fieldId) {
  if (MAIN_ROW_ONLY[type]) return MAIN_ROW_ONLY[type].has(fieldId);
  if (SUB_ROW_EDITABLE[type]) return !SUB_ROW_EDITABLE[type].has(fieldId);
  return false;
}

// ================================================================
// UNIFIED LOAD FILE  (auto-detect format from extension)
// ================================================================
function loadFile() {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.multiple = true;
  inp.accept = '.w3t,.w3a,.w3u,.w3b,.w3h,.w3d,.w3q,.json';
  inp.onchange = e => {
    const files = [...e.target.files]; if (!files.length) return;
    let lastType = null;
    let pending = files.length;
    function done(type) { lastType = type; if (--pending === 0 && lastType) switchTab(lastType); }

    for (const f of files) {
      const ext = f.name.split('.').pop().toLowerCase();

      if (ext === 'json') {
        const rd = new FileReader();
        rd.onload = ev => {
          try {
            const json = JSON.parse(ev.target.result);
            const fileExt = json._type || 'w3t';
            const hasLevels = json._hasLevels || TYPES_WITH_LEVELS.has(fileExt);
            const parsed = { version: json.version || 3, hasLevels, ext: fileExt,
              objects: { original: json.original || json.original_items || [], custom: json.custom || json.custom_items || [] } };
            const detectedType = extToType(fileExt) || 'items';
            ingestParsed(detectedType, parsed, f.name);
            done(detectedType);
          } catch (err) { alert('JSON error (' + f.name + '): ' + err.message); done(null); }
        };
        rd.readAsText(f);
        continue;
      }

      const info = EXT_INFO[ext];
      if (!info) { alert('Unsupported file type: .' + ext); done(null); continue; }
      const detectedType = extToType(ext) || 'items';

      const rd = new FileReader();
      rd.onload = ev => {
        try {
          const parsed = parseBinaryBuffer(ev.target.result, ext);
          ingestParsed(detectedType, parsed, f.name);
          done(detectedType);
        } catch (err) {
          alert('Binary parse error (' + f.name + '): ' + err.message + '\n' + err.stack);
          done(null);
        }
      };
      rd.readAsArrayBuffer(f);
    }
  };
  inp.click();
}

// ================================================================
// LOAD BINARY FILE  (browser ArrayBuffer)
// ================================================================
function loadBinaryFile(type) {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = '.w3t,.w3a,.w3u,.w3b,.w3h,.w3d,.w3q';
  inp.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const ext = f.name.split('.').pop().toLowerCase();
    const info = EXT_INFO[ext];
    if (!info) { alert('Unsupported file type: .' + ext); return; }

    // Auto-detect tab from extension
    const detectedType = extToType(ext) || 'items';

    const rd = new FileReader();
    rd.onload = ev => {
      try {
        const parsed = parseBinaryBuffer(ev.target.result, ext);
        ingestParsed(detectedType, parsed, f.name);
        switchTab(detectedType);
      } catch (err) {
        alert('Binary parse error: ' + err.message + '\n' + err.stack);
      }
    };
    rd.readAsArrayBuffer(f);
  };
  inp.click();
}

// ================================================================
// LOAD JSON FILE  (legacy import, for backwards compatibility)
// ================================================================
function loadJSONFile() {
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = '.json';
  inp.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = ev => {
      try {
        const json = JSON.parse(ev.target.result);
        const ext = json._type || 'w3t';
        const hasLevels = json._hasLevels || TYPES_WITH_LEVELS.has(ext);
        const parsed = {
          version: json.version || 3,
          hasLevels,
          ext,
          objects: {
            original: json.original || json.original_items || [],
            custom:   json.custom   || json.custom_items   || [],
          }
        };
        const detectedType = extToType(ext) || 'items';
        ingestParsed(detectedType, parsed, f.name);
        switchTab(detectedType);
      } catch (err) { alert('JSON error: ' + err.message); }
    };
    rd.readAsText(f);
  };
  inp.click();
}

// ================================================================
// INGEST parsed binary/json data into editor state
// ================================================================
function ingestParsed(type, parsed, fileName) {
  const { version, hasLevels, ext, objects } = parsed;

  const meta = {
    _format: 'war3map.' + ext,
    _type: ext,
    _hasLevels: hasLevels,
    version: version,
    _fileName: fileName,
  };

  const fieldsMap = new Map(); // fieldId -> { name, type }
  const unsortedRows = [];
  let gid = 0;

  for (const tbl of ['original', 'custom']) {
    const objs = objects[tbl] || [];

    for (const obj of objs) {
      if (!hasLevels) {
        // Simple objects: one row per object
        const row = makeRow(gid++, tbl, obj);
        for (const f of obj.fields) {
          row.v[f.id] = { val: f.value, type: f.type, endTag: f.endTag };
          row._fo.push(f.id);
          registerField(fieldsMap, f.id, f.type);
        }
        unsortedRows.push(row);
      } else {
        // Leveled objects: one head row (level 0) + sub-rows for levels 1..N
        // N = max(level_count_field_value, max_level_in_data)
        const gfo = obj.fields.map(f => ({ id: f.id, lvl: f.level ?? 0 }));
        const detectedType = type;
        const lcfId = LEVEL_COUNT_FIELD[type] || null;

        // Determine level count from the field (alev/glvl/dvar)
        let levelCountFromField = 0;
        if (lcfId) {
          for (const f of obj.fields) {
            if (f.id === lcfId) {
              levelCountFromField = parseInt(f.value) || 0;
              break;
            }
          }
        }
        // Find the max level referenced by any data field
        let maxLevelInData = 0;
        for (const f of obj.fields) {
          const lvl = f.level ?? 0;
          if (lvl > maxLevelInData) maxLevelInData = lvl;
        }
        // The number of sub-rows = max of the two
        const numLevels = Math.max(levelCountFromField, maxLevelInData);

        // Distribute fields into per-level buckets
        const byLevel = new Map();
        byLevel.set(0, []); // head row always exists
        for (let l = 1; l <= numLevels; l++) {
          byLevel.set(l, []); // pre-create all level rows 1..N
        }

        for (const f of obj.fields) {
          const origLvl = f.level ?? 0;
          registerField(fieldsMap, f.id, f.type);

          // Main-row-only fields → head row (level 0)
          if (isMainRowOnly(detectedType, f.id)) {
            byLevel.get(0).push({ ...f, _origLevel: origLvl });
          } else {
            // Level-specific fields stay at their exact original level
            let lvl = origLvl;
            if (lvl < 0) lvl = 0;
            if (!byLevel.has(lvl)) byLevel.set(lvl, []);
            byLevel.get(lvl).push({ ...f, _origLevel: origLvl });
          }
        }

        const levels = [...byLevel.keys()].sort((a, b) => a - b);
        const g = gid++;
        for (let li = 0; li < levels.length; li++) {
          const lvl = levels[li];
          const row = makeRow(g, tbl, obj, lvl);
          if (li === 0) row._gfo = gfo; // store original field order on first row
          for (const f of (byLevel.get(lvl) || [])) {
            row.v[f.id] = { val: f.value, type: f.type, col: f.column, endTag: f.endTag,
                            _origLevel: f._origLevel };
            row._fo.push(f.id);
          }
          unsortedRows.push(row);
        }
      }
    }
  }

  // Sort rows so entries with the same base_id are grouped together,
  // mixing original and custom. Within a base_id group: original first,
  // then custom sorted by custom_id.
  // Collect groups by gid first to keep sub-rows together with their head.
  const groupMap = new Map(); // gid -> { bid, cid, tbl, rows[] }
  const groupOrder = [];
  for (const row of unsortedRows) {
    if (!groupMap.has(row.gid)) {
      groupMap.set(row.gid, { bid: row.bid, cid: row.cid, tbl: row.tbl, rows: [] });
      groupOrder.push(row.gid);
    }
    groupMap.get(row.gid).rows.push(row);
  }

  // Sort group keys by base_id, then original-before-custom, then custom_id
  groupOrder.sort((a, b) => {
    const ga = groupMap.get(a), gb = groupMap.get(b);
    if (ga.bid < gb.bid) return -1;
    if (ga.bid > gb.bid) return 1;
    // Same base_id: original before custom
    if (ga.tbl !== gb.tbl) return ga.tbl === 'original' ? -1 : 1;
    // Same table: sort by custom_id
    const ca = ga.cid || '', cb = gb.cid || '';
    return ca.localeCompare(cb);
  });

  // Re-assign sequential gids and flatten
  const rows = [];
  let newGid = 0;
  for (const oldGid of groupOrder) {
    const g = groupMap.get(oldGid);
    const assignedGid = newGid++;
    for (const row of g.rows) {
      row.gid = assignedGid;
      rows.push(row);
    }
  }

  // Build ordered column list
  const pri = type === 'units' ? UNIT_PRI : (type === 'buffs' ? BUFF_PRI : (type === 'upgrades' ? UPGR_PRI : (type === 'destructables' ? DEST_PRI : (type === 'doodads' ? DOOD_PRI : (hasLevels ? ABIL_PRI : ITEM_PRI)))));
  const colIds = sortFieldIds([...fieldsMap.keys()], pri);
  const cols = colIds.map(id => ({ id, name: fieldsMap.get(id).name, type: fieldsMap.get(id).type }));

  S[type] = { meta, rows, cols };
  renderTable(type);
  updateTabLabel(type);
}

function makeRow(gid, tbl, obj, lvl) {
  return {
    gid, tbl,
    bid: obj.base_id,
    cid: obj.custom_id || '',
    _endTag: obj._endTag || null,
    lvl: lvl ?? null,
    v: {},
    _fo: []
  };
}

function registerField(map, id, type) {
  if (!map.has(id)) map.set(id, { name: fieldName(id), type });
}

function sortFieldIds(ids, priority) {
  const priMap = {};
  priority.forEach((id, i) => priMap[id] = i);
  return ids.sort((a, b) => {
    const pa = priMap[a] ?? 9999, pb = priMap[b] ?? 9999;
    if (pa !== pb) return pa - pb;
    return a.localeCompare(b);
  });
}

// ================================================================
// RENDER TABLE
// ================================================================
function renderTable(type) {
  const st = S[type]; if (!st) return;
  const { meta, rows, cols } = st;
  const hl = meta._hasLevels;
  const lcf = LEVEL_COUNT_FIELD[type] || null;
  const pane = document.getElementById(type + 'Pane');

  let h = '<div class="tw"><table>';

  if (!hl) {
    // ---- Non-leveled: flat header with all columns ----
    h += '<thead><tr>';
    h += '<th style="width:40px" data-default-w="40">#<span class="col-resize" data-ci="0"></span></th>';
    h += '<th style="width:52px" data-default-w="52"><span class="col-resize" data-ci="1"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Table<span class="col-resize" data-ci="2"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Base ID<span class="col-resize" data-ci="3"></span></th>';
    h += '<th style="width:70px" data-default-w="70">Custom ID<span class="col-resize" data-ci="4"></span></th>';
    let ci = 5;
    for (const c of cols) {
      h += '<th style="width:160px" data-default-w="160" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + '</span><span class="col-resize" data-ci="' + ci + '"></span></th>';
      ci++;
    }
    h += '</tr></thead><tbody>';

    // ---- Non-leveled: simple flat rows ----
    let prevGid = -1, groupAlt = false;
    for (let ri = 0; ri < rows.length; ri++) {
      const r = rows[ri];
      if (r.gid !== prevGid) { groupAlt = !groupAlt; prevGid = r.gid; }
      const rc = r.tbl === 'original' ? 'r0' : 'r1';
      const ga = groupAlt ? 'ga' : '';
      const searchText = esc([r.bid, r.cid, ...Object.keys(r.v).map(k => r.v[k].val)].join(' ').toLowerCase());

      h += '<tr class="' + rc + ' ' + ga + '" data-s="' + searchText + '">';
      h += '<td style="color:#555;text-align:right;padding-right:4px">' + (ri + 1) + '</td>';
      h += '<td class="del-c"><button class="btn b-del b-sm" onclick="removeRow(\'' + type + '\',' + ri + ')" title="Remove row">&times;</button><button class="btn b-add b-sm" onclick="duplicateRow(\'' + type + '\',' + ri + ')" title="Duplicate row" style="margin-left:2px">&#x2398;</button></td>';
      h += '<td style="font-size:11px;color:#999">' + r.tbl + '</td>';
      h += '<td class="idc">' + esc(r.bid) + '</td>';
      h += '<td class="idc">' + esc(r.cid || '\u2014') + '</td>';
      h += renderCells(ri, r, cols);
      h += '</tr>';
    }
  } else {
    // ---- Leveled: split columns into main-row and level-specific ----
    const mainCols = [];
    const levelCols = [];
    for (const c of cols) {
      if (isMainRowOnly(type, c.id) || (lcf && c.id === lcf)) {
        mainCols.push(c);
      } else {
        levelCols.push(c);
      }
    }

    // Outer table header: only fixed columns + main-row columns
    h += '<thead><tr>';
    h += '<th style="width:40px" data-default-w="40">#<span class="col-resize" data-ci="0"></span></th>';
    h += '<th style="width:52px" data-default-w="52"><span class="col-resize" data-ci="1"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Table<span class="col-resize" data-ci="2"></span></th>';
    h += '<th style="width:60px" data-default-w="60">Base ID<span class="col-resize" data-ci="3"></span></th>';
    h += '<th style="width:70px" data-default-w="70">Custom ID<span class="col-resize" data-ci="4"></span></th>';
    let ci = 5;
    for (const c of mainCols) {
      h += '<th style="width:160px" data-default-w="160" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + '</span><span class="col-resize" data-ci="' + ci + '"></span></th>';
      ci++;
    }
    h += '</tr></thead><tbody>';

    const totalOuterCols = 5 + mainCols.length;

    // Build groups in order
    const groups = [];
    const groupMap = new Map();
    for (let ri = 0; ri < rows.length; ri++) {
      const r = rows[ri];
      if (!groupMap.has(r.gid)) {
        const g = { gid: r.gid, indices: [] };
        groupMap.set(r.gid, g);
        groups.push(g);
      }
      groupMap.get(r.gid).indices.push(ri);
    }

    // Pre-compute merged level columns per base_id:
    // Groups with the same bid share the same set of level columns.
    const bidGroupMap = new Map(); // bid -> [group indices into groups[]]
    for (let gi = 0; gi < groups.length; gi++) {
      const grp = groups[gi];
      const bid = rows[grp.indices[0]].bid;
      if (!bidGroupMap.has(bid)) bidGroupMap.set(bid, []);
      bidGroupMap.get(bid).push(gi);
    }
    // For each bid, collect the union of level columns that have data in any
    // sub-row of any group with that bid.
    const bidLevelCols = new Map(); // bid -> levelCol[]
    for (const [bid, gIndices] of bidGroupMap) {
      const usedColIds = new Set();
      for (const gi of gIndices) {
        const grp = groups[gi];
        const indices = grp.indices;
        for (const ri of indices) {
          if ((rows[ri].lvl ?? 0) === 0) continue; // skip head rows
          for (const c of levelCols) {
            const cell = rows[ri].v[c.id];
            if (cell && cell.val !== '' && cell.val !== null && cell.val !== undefined) usedColIds.add(c.id);
          }
        }
      }
      bidLevelCols.set(bid, levelCols.filter(c => usedColIds.has(c.id)));
    }

    let groupAlt = false;
    for (const grp of groups) {
      groupAlt = !groupAlt;
      const indices = grp.indices;
      // Sort: level 0 first, then ascending
      indices.sort((a, b) => (rows[a].lvl ?? 0) - (rows[b].lvl ?? 0));

      const headIdx = indices[0];
      const headRow = rows[headIdx];
      const subIndices = indices.filter(ri => (rows[ri].lvl ?? 0) > 0);
      const rc = headRow.tbl === 'original' ? 'r0' : 'r1';
      const ga = groupAlt ? 'ga' : '';

      // Collect search text from entire group
      const allGroupText = indices.map(ri => {
        const r = rows[ri];
        return [r.bid, r.cid, ...Object.keys(r.v).map(k => r.v[k].val)].join(' ').toLowerCase();
      }).join(' ');
      const searchText = esc(allGroupText);

      // ---- Head row: main-row columns only ----
      h += '<tr class="' + rc + ' ' + ga + ' grp-head" data-s="' + searchText + '" data-gid="' + headRow.gid + '">';
      h += '<td style="color:#555;text-align:right;padding-right:4px">' + (headIdx + 1) + '</td>';
      h += '<td class="del-c"><button class="btn b-del b-sm" onclick="removeGroup(\'' + type + '\',' + headRow.gid + ')" title="Remove object">&times;</button><button class="btn b-add b-sm" onclick="duplicateRow(\'' + type + '\',' + headIdx + ')" title="Duplicate object" style="margin-left:2px">&#x2398;</button></td>';
      h += '<td style="font-size:11px;color:#999">' + headRow.tbl + '</td>';
      h += '<td class="idc">' + esc(headRow.bid) + '</td>';
      h += '<td class="idc">' + esc(headRow.cid || '\u2014') + '</td>';
      h += renderCells(headIdx, headRow, mainCols, null, type, headRow.gid, null);
      h += '</tr>';

      // ---- Level sub-table: use merged columns for this bid ----
      const mergedLevelCols = bidLevelCols.get(headRow.bid) || [];
      if (mergedLevelCols.length > 0 && subIndices.length > 0) {
        h += '<tr class="' + rc + ' ' + ga + ' sub-table-row" data-gid="' + headRow.gid + '" data-s="' + searchText + '">';
        h += '<td colspan="' + totalOuterCols + '">';
        h += '<table class="level-table">';
        h += '<thead><tr>';
        h += '<th style="width:30px" data-default-w="30">Lvl</th>';
        let lci = 1;
        for (const c of mergedLevelCols) {
          h += '<th style="width:140px" data-default-w="140" data-code="' + esc(c.id) + '" title="' + esc(c.id) + ' (' + c.type + ')">' + esc(c.name) + '<span class="sub">' + esc(c.id) + '</span><span class="col-resize" data-ci="' + lci + '"></span></th>';
          lci++;
        }
        h += '</tr></thead><tbody>';

        for (const si of subIndices) {
          const sr = rows[si];
          const src = sr.tbl === 'original' ? 'r0' : 'r1';
          h += '<tr class="' + src + '">';
          h += '<td class="sr-lvl">' + (sr.lvl ?? '') + '</td>';
          h += renderCells(si, sr, mergedLevelCols, null, type, sr.gid);
          h += '</tr>';
        }

        h += '</tbody></table></td></tr>';
      }
    }
  }

  h += '</tbody></table></div>';
  pane.innerHTML = h;
  updateStats(type);
}

/** Render the data cells for a row (shared between main and sub-rows).
 *  subRowType: if truthy, fields marked main-row-only are rendered read-only.
 *  ownerType/gid: used for context. */
function renderCells(ri, r, cols, subRowType, ownerType, gid) {
  let h = '';
  const lcf = ownerType ? (LEVEL_COUNT_FIELD[ownerType] || null) : null;
  for (const c of cols) {
    // Level-count field: render as editable number that also triggers changeLevelCount
    if (lcf && c.id === lcf && !subRowType) {
      const cell = r.v[c.id];
      const storedVal = cell ? (cell.val ?? '') : '';
      h += '<td style="text-align:center"><input type="number" min="0" value="' + storedVal + '" data-r="' + ri + '" data-f="' + c.id + '" style="width:48px;background:#252550;color:#e0e0e0;border:1px solid #0f3460;border-radius:2px;font:11px Consolas,monospace;text-align:center;padding:1px" onchange="changeLevelCount(\'' + ownerType + '\',' + gid + ',this.value)" title="Number of levels/variations (source value)"></td>';
      continue;
    }

    const cell = r.v[c.id];
    let val = cell ? cell.val ?? '' : '';
    if (val !== '' && (c.type === 'real' || c.type === 'unreal')) val = parseFloat(Number(val).toFixed(3));

    // Read-only cell for sub-rows where this field is main-row-only
    if (subRowType && isMainRowOnly(subRowType, c.id)) {
      h += '<td class="ro-cell">' + esc(String(val)) + '</td>';
      continue;
    }

    const mt = getMetaType(c.id);
    const opts = mt ? META_TYPE_OPTIONS[mt] : null;
    if (opts) {
      h += '<td><select data-r="' + ri + '" data-f="' + c.id + '" data-mt="' + (mt||'') + '">';
      h += '<option value=""' + (val === '' ? ' selected' : '') + '></option>';
      for (const o of opts) {
        const sel = (String(val) === o.value) ? ' selected' : '';
        h += '<option value="' + escA(o.value) + '"' + sel + '>' + esc(o.label) + '</option>';
      }
      h += '</select></td>';
    } else {
      h += '<td><input value="' + escA(String(val)) + '" data-r="' + ri + '" data-f="' + c.id + '" data-mt="' + (mt||'') + '"></td>';
    }
  }
  return h;
}

function updateTabLabel(type) {
  const st = S[type]; if (!st) return;
  const label = {items:'Items', abilities:'Abilities', units:'Units', buffs:'Buffs', upgrades:'Upgrades', destructables:'Destructables', doodads:'Doodads'}[type] || type;
  const n = st.rows.length;
  const fname = st.meta._fileName ? (' \u2014 ' + st.meta._fileName) : '';
  document.querySelector('.tab[data-t="' + type + '"]').textContent = label + ' (' + n + ' rows)' + fname;
}

function updateStats(type) {
  const st = S[type];
  if (!st) { document.getElementById('statsBar').textContent = ''; return; }
  const origObjs = new Set(st.rows.filter(r => r.tbl === 'original').map(r => r.gid)).size;
  const custObjs = new Set(st.rows.filter(r => r.tbl === 'custom').map(r => r.gid)).size;
  const filledCells = st.rows.reduce((s, r) => s + Object.keys(r.v).length, 0);
  document.getElementById('statsBar').textContent =
    origObjs + ' original + ' + custObjs + ' custom objects  |  ' +
    st.cols.length + ' columns  |  ' + filledCells + ' values  |  v' +
    st.meta.version + '  |  .' + st.meta._type;
}

// ================================================================
// SYNC DOM -> STATE
// ================================================================
function syncDOM(type) {
  const st = S[type]; if (!st) return;
  const pane = document.getElementById(type + 'Pane');
  // Gather both <input> and <select> elements with data-r
  const elems = pane.querySelectorAll('input[data-r], select[data-r]');
  for (const el of elems) {
    const ri = parseInt(el.dataset.r);
    const fid = el.dataset.f;
    const row = st.rows[ri];
    if (!row) continue;
    const raw = el.value;

    if (row.v[fid]) {
      // Existing cell - update value
      const cell = row.v[fid];
      if (cell.type === 'int') { const n = parseInt(raw, 10); cell.val = isNaN(n) ? 0 : n; }
      else if (cell.type === 'real' || cell.type === 'unreal') { const n = parseFloat(raw); cell.val = isNaN(n) ? 0 : n; }
      else cell.val = raw;
    } else if (raw !== '') {
      // New cell - create only if user typed/selected something
      const col = st.cols.find(c => c.id === fid);
      const ctype = col ? col.type : 'string';
      const cell = { val: raw, type: ctype };
      if (ctype === 'int') { const n = parseInt(raw, 10); cell.val = isNaN(n) ? 0 : n; }
      else if (ctype === 'real' || ctype === 'unreal') { const n = parseFloat(raw); cell.val = isNaN(n) ? 0 : n; }
      if (st.meta._hasLevels) cell.col = 0;
      row.v[fid] = cell;
    }
  }
}

// ================================================================
// EXPORT BINARY  (.w3t / .w3a / etc.)
// ================================================================
function exportBinary(type) {
  // If no type specified, use active tab
  if (!type) type = activeTab;
  
  // Use active tab if specified type has no data
  if (!S[type] && S[activeTab]) type = activeTab;
  const st = S[type];
  if (!st) { alert('No ' + type + ' data loaded.'); return; }

  const writer = buildBinaryFromState(type);
  if (!writer) { alert('No ' + type + ' data loaded.'); return; }

  const ext = st.meta._type || 'w3t';
  const blob = writer.toBlob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = st.meta._fileName || ('war3map.' + ext);
  a.click();
  URL.revokeObjectURL(url);
}

// ================================================================
// EXPORT JSON  (debug / legacy)
// ================================================================
function exportJSON() {
  const type = activeTab;
  const st = S[type];
  if (!st) { alert('No ' + type + ' data loaded.'); return; }
  syncDOM(type);

  const hasLevels = st.meta._hasLevels;
  const json = {
    _format: st.meta._format,
    _type: st.meta._type,
    _hasLevels: hasLevels,
    version: st.meta.version,
    original: [],
    custom: [],
  };

  if (!hasLevels) {
    for (const row of st.rows) {
      const obj = { base_id: row.bid, custom_id: row.cid || null, fields: [] };
      const ordered = orderedFieldIds(row, st.cols);
      for (const fid of ordered) {
        const cell = row.v[fid]; if (!cell) continue;
        const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
        obj.fields.push({ id: fid, type: ftype, value: coerceVal(cell.val, ftype) });
      }
      json[row.tbl].push(obj);
    }
  } else {
    const groups = new Map();
    const groupOrder = [];
    for (const row of st.rows) {
      if (!groups.has(row.gid)) { groups.set(row.gid, []); groupOrder.push(row.gid); }
      groups.get(row.gid).push(row);
    }
    for (const gid of groupOrder) {
      const gRows = groups.get(gid);
      const first = gRows[0];
      const obj = { base_id: first.bid, custom_id: first.cid || null, fields: [] };
      const rowByLevel = {};
      for (const row of gRows) rowByLevel[row.lvl] = row;

      if (first._gfo && first._gfo.length > 0) {
        const used = new Set();
        for (const { id: fid, lvl } of first._gfo) {
          const key = fid + '@' + lvl;
          if (used.has(key)) continue;
          used.add(key);
          let row = rowByLevel[lvl];
          let cell = row ? row.v[fid] : null;
          if (!cell && rowByLevel[0]) {
            row = rowByLevel[0];
            cell = row.v[fid];
          }
          if (!row || !cell) continue;
          const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
          const writeLevel = cell._origLevel != null ? cell._origLevel : lvl;
          obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                            value: coerceVal(cell.val, ftype) });
        }
        for (const row of gRows) {
          for (const c of st.cols) {
            const key = c.id + '@' + (row.v[c.id]?._origLevel != null ? row.v[c.id]._origLevel : row.lvl);
            if (used.has(key)) continue;
            const cell = row.v[c.id]; if (!cell) continue;
            used.add(key);
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: c.id, type: cell.type || c.type, level: writeLevel,
                              column: cell.col ?? 0, value: coerceVal(cell.val, cell.type || c.type) });
          }
        }
      } else {
        for (const row of gRows) {
          const ordered = orderedFieldIds(row, st.cols);
          for (const fid of ordered) {
            const cell = row.v[fid]; if (!cell) continue;
            const ftype = cell.type || (st.cols.find(c => c.id === fid) || {}).type || 'string';
            const writeLevel = cell._origLevel != null ? cell._origLevel : (row.lvl ?? 0);
            obj.fields.push({ id: fid, type: ftype, level: writeLevel, column: cell.col ?? 0,
                              value: coerceVal(cell.val, ftype) });
          }
        }
      }
      json[first.tbl].push(obj);
    }
  }

  const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (type || 'data') + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

// Ordered field IDs: original order first, then any new fields
function orderedFieldIds(row, cols) {
  const seen = new Set(row._fo || []);
  const result = [...(row._fo || [])];
  for (const c of cols) {
    if (!seen.has(c.id) && row.v[c.id]) { result.push(c.id); }
  }
  return result;
}

function coerceVal(v, type) {
  if (type === 'int') { const n = parseInt(v, 10); return isNaN(n) ? 0 : n; }
  if (type === 'real' || type === 'unreal') { const n = parseFloat(v); return isNaN(n) ? 0 : n; }
  return String(v);
}

// ================================================================
// AUTO-GENERATE NEXT UNUSED CUSTOM ID
// Items: I + 3 chars, Abilities: A + 3 chars, Units: U + 3 chars (0-9a-z)
// ================================================================
const ID_CHARS = '0123456789abcdefghijklmnopqrstuvwxyz';

function nextUnusedId(type) {
  const prefix = {abilities:'A', units:'U', buffs:'B', upgrades:'R', destructables:'D', doodads:'O', items:'I'}[type] || 'X';
  // Collect all existing custom IDs across all tabs
  const used = new Set();
  for (const key of ['items', 'abilities', 'units', 'buffs', 'upgrades', 'destructables', 'doodads']) {
    if (!S[key]) continue;
    for (const row of S[key].rows) {
      if (row.cid) used.add(row.cid);
    }
  }
  // Iterate through all 36^3 = 46656 combinations
  for (let i = 0; i < 36 * 36 * 36; i++) {
    const c0 = ID_CHARS[Math.floor(i / (36 * 36)) % 36];
    const c1 = ID_CHARS[Math.floor(i / 36) % 36];
    const c2 = ID_CHARS[i % 36];
    const id = prefix + c0 + c1 + c2;
    if (!used.has(id)) return id;
  }
  alert('No unused IDs remaining!');
  return null;
}

// ================================================================
// TAB SWITCHING
// ================================================================
function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.t === tab));
  for (const k of ['items','abilities','units','buffs','upgrades','destructables','doodads']) {
    document.getElementById(k + 'Pane').classList.toggle('hidden', tab !== k);
  }
  updateStats(tab);
}

// ================================================================
// SEARCH / FILTER
// ================================================================
function filterRows() {
  const q = document.getElementById('searchBox').value.toLowerCase().trim();
  const pane = document.getElementById(activeTab + 'Pane');
  const trs = pane.querySelectorAll('tbody tr');
  if (!q) { trs.forEach(tr => tr.style.display = ''); return; }

  const st = S[activeTab];
  if (st && st.meta._hasLevels) {
    // For leveled types, show entire group if any row matches
    const matchedGids = new Set();
    trs.forEach(tr => {
      if ((tr.dataset.s || '').includes(q)) matchedGids.add(tr.dataset.gid);
    });
    trs.forEach(tr => {
      tr.style.display = matchedGids.has(tr.dataset.gid) ? '' : 'none';
    });
  } else {
    trs.forEach(tr => {
      tr.style.display = (tr.dataset.s || '').includes(q) ? '' : 'none';
    });
  }
}

// ================================================================
// ADD ROW
// ================================================================
function showAddRow() {
  if (!S[activeTab]) { alert('Load data first.'); return; }
  document.getElementById('popRowTitle').textContent = 'Add New ' + ({items:'Item', abilities:'Ability', units:'Unit', buffs:'Buff', upgrades:'Upgrade', destructables:'Destructable', doodads:'Doodad'}[activeTab] || 'Object');
  document.getElementById('arLevelWrap').style.display = (S[activeTab]?.meta._hasLevels) ? '' : 'none';
  document.getElementById('arBase').value = '';
  document.getElementById('arLevels').value = '1';
  document.getElementById('popRow').classList.remove('hidden');
  document.getElementById('arBase').focus();
}

function confirmAddRow() {
  const type = activeTab;
  const st = S[type]; if (!st) return;
  syncDOM(type);

  const bid = document.getElementById('arBase').value.trim();
  const tbl = document.getElementById('arTable').value;
  if (!bid || bid.length !== 4) { alert('Base ID must be exactly 4 characters.'); return; }

  let cid = '';
  if (tbl === 'custom') {
    cid = nextUnusedId(type);
    if (!cid) return;
  }

  const gid = st.rows.length > 0 ? Math.max(...st.rows.map(r => r.gid)) + 1 : 0;

  if (!st.meta._hasLevels) {
    st.rows.push({ gid, tbl, bid, cid, lvl: null, v: {}, _fo: [] });
  } else {
    const nLevels = parseInt(document.getElementById('arLevels').value) || 1;
    for (let l = 0; l <= nLevels; l++) {
      st.rows.push({ gid, tbl, bid, cid, lvl: l, v: {}, _fo: [] });
    }
  }

  renderTable(type);
  updateTabLabel(type);
  closePopup('popRow');
}

function removeRow(type, idx) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  if (!confirm('Remove this row?')) return;
  const scrollPos = saveScroll(type);
  st.rows.splice(idx, 1);
  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

/** Remove all rows belonging to a group (leveled objects). */
function removeGroup(type, gid) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  if (!confirm('Remove this object and all its levels?')) return;
  const scrollPos = saveScroll(type);
  st.rows = st.rows.filter(r => r.gid !== gid);
  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

/** Change the number of sub-rows (levels/variations) for a group. */
function changeLevelCount(type, gid, rawVal) {
  const st = S[type]; if (!st) return;
  syncDOM(type);
  const scrollPos = saveScroll(type);

  let desired = parseInt(rawVal, 10);
  if (isNaN(desired) || desired < 0) desired = 0;

  // Find all rows in this group, sorted by level
  const groupRows = st.rows.filter(r => r.gid === gid);
  if (groupRows.length === 0) return;
  groupRows.sort((a, b) => (a.lvl ?? 0) - (b.lvl ?? 0));

  const head = groupRows[0]; // level-0 row
  const currentSubs = groupRows.filter(r => r.lvl > 0);
  const currentCount = currentSubs.length;

  if (desired === currentCount) return;

  // Also update the level-count field in the head row's data
  const lcf = LEVEL_COUNT_FIELD[type];
  if (lcf) {
    if (head.v[lcf]) head.v[lcf].val = desired;
    else head.v[lcf] = { val: desired, type: 'int', col: 0 };
  }

  if (desired > currentCount) {
    // Add new sub-rows after the last row of this group
    const lastIdx = st.rows.lastIndexOf(groupRows[groupRows.length - 1]);
    const startLvl = currentCount + 1;
    const newRows = [];
    for (let l = startLvl; l <= desired; l++) {
      newRows.push({
        gid: head.gid, tbl: head.tbl,
        bid: head.bid, cid: head.cid,
        _endTag: head._endTag,
        lvl: l, v: {}, _fo: []
      });
    }
    st.rows.splice(lastIdx + 1, 0, ...newRows);
  } else {
    // Remove excess sub-rows (highest levels first)
    const toRemove = new Set();
    for (let i = currentSubs.length - 1; i >= desired; i--) {
      toRemove.add(currentSubs[i]);
    }
    st.rows = st.rows.filter(r => !toRemove.has(r));
  }

  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

function duplicateRow(type, idx) {
  const st = S[type]; if (!st) return;
  syncDOM(type);

  const scrollPos = saveScroll(type);
  const src = st.rows[idx];
  const newCid = nextUnusedId(type);
  if (!newCid) return;

  const newGid = st.rows.length > 0 ? Math.max(...st.rows.map(r => r.gid)) + 1 : 0;

  if (!st.meta._hasLevels) {
    // Simple: duplicate single row
    const newRow = {
      gid: newGid, tbl: 'custom',
      bid: src.bid, cid: newCid,
      lvl: src.lvl,
      v: JSON.parse(JSON.stringify(src.v)),
      _fo: [...(src._fo || [])]
    };
    st.rows.splice(idx + 1, 0, newRow);
  } else {
    // Leveled: duplicate all rows in the same group
    const srcGid = src.gid;
    const groupRows = st.rows.filter(r => r.gid === srcGid);
    // Find insertion point: after last row of this group
    let lastIdx = idx;
    for (let i = 0; i < st.rows.length; i++) {
      if (st.rows[i].gid === srcGid) lastIdx = i;
    }
    const newRows = groupRows.map((r, i) => {
      const nr = {
        gid: newGid, tbl: 'custom',
        bid: r.bid, cid: newCid,
        lvl: r.lvl,
        v: JSON.parse(JSON.stringify(r.v)),
        _fo: [...(r._fo || [])]
      };
      if (i === 0 && r._gfo) nr._gfo = JSON.parse(JSON.stringify(r._gfo));
      return nr;
    });
    st.rows.splice(lastIdx + 1, 0, ...newRows);
  }

  renderTable(type);
  updateTabLabel(type);
  restoreScroll(type, scrollPos);
}

// ================================================================
// SCROLL SAVE / RESTORE
// ================================================================
function saveScroll(type) {
  const pane = document.getElementById(type + 'Pane');
  const tw = pane ? pane.querySelector('.tw') : null;
  return tw ? { top: tw.scrollTop, left: tw.scrollLeft } : { top: 0, left: 0 };
}
function restoreScroll(type, pos) {
  if (!pos) return;
  const pane = document.getElementById(type + 'Pane');
  const tw = pane ? pane.querySelector('.tw') : null;
  if (tw) { tw.scrollTop = pos.top; tw.scrollLeft = pos.left; }
}

// ================================================================
// POPUP / ESCAPE HELPERS
// ================================================================
function closePopup(id) { document.getElementById(id).classList.add('hidden'); }
function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function escA(s) { return String(s).replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ================================================================
// DOUBLE-CLICK COLUMN HEADER TO AUTO-FIT WIDTH (toggle: auto-fit / default)
// ================================================================
function setColWidth(th, w, cells) {
  th.style.width = w + 'px';
  th.style.minWidth = w + 'px';
  th.style.maxWidth = w + 'px';
  for (const td of cells) {
    td.style.width = w + 'px';
    td.style.minWidth = w + 'px';
    td.style.maxWidth = w + 'px';
  }
}
function getDirectCells(table, ci) {
  return Array.from(table.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (ci + 1) + ')'));
}
document.addEventListener('dblclick', function(e) {
  const th = e.target.closest('th');
  if (!th || e.target.closest('.col-resize')) return;
  const table = th.closest('table');
  if (!table) return;
  const ci = Array.from(th.parentElement.children).indexOf(th);
  if (ci < 0) return;
  const isLevelTable = table.classList.contains('level-table');
  const isExpanded = th.dataset.expanded === '1';

  // Collect all related ths and cells (for level-table sync)
  let allThs = [th];
  let allCellSets = [{ th: th, cells: getDirectCells(table, ci) }];
  if (isLevelTable && th.dataset.code) {
    const code = th.dataset.code;
    document.querySelectorAll('.level-table th[data-code="' + code + '"]').forEach(function(otherTh) {
      if (otherTh === th) return;
      allThs.push(otherTh);
      const otherTable = otherTh.closest('table');
      const otherCi = Array.from(otherTh.parentElement.children).indexOf(otherTh);
      allCellSets.push({ th: otherTh, cells: getDirectCells(otherTable, otherCi) });
    });
  }

  if (isExpanded) {
    // ---- Restore default width ----
    for (const s of allCellSets) {
      const defW = parseInt(s.th.dataset.defaultW) || 140;
      setColWidth(s.th, defW, s.cells);
      s.th.dataset.expanded = '0';
    }
  } else {
    // ---- Auto-fit: measure widest content across all related columns ----
    let maxW = 30;
    const measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;font:12px Consolas,monospace;padding:2px 6px';
    document.body.appendChild(measurer);
    for (const s of allCellSets) {
      // measure header text
      measurer.textContent = s.th.textContent;
      maxW = Math.max(maxW, measurer.offsetWidth + 12);
      for (const td of s.cells) {
        const inp = td.querySelector('input,select');
        const text = inp ? inp.value : td.textContent;
        measurer.textContent = text;
        maxW = Math.max(maxW, measurer.offsetWidth + 12);
      }
    }
    document.body.removeChild(measurer);
    for (const s of allCellSets) {
      setColWidth(s.th, maxW, s.cells);
      s.th.dataset.expanded = '1';
    }
  }
});

// ================================================================
// COLUMN RESIZE
// ================================================================
(function() {
  let resizing = false, startX = 0, startW = 0, th = null, colIdx = -1;
  function applyColWidth(newW) {
    th.style.width = newW + 'px';
    th.style.minWidth = newW + 'px';
    th.style.maxWidth = newW + 'px';
    const table = th.closest('table');
    if (!table) return;
    // Use :scope > to avoid matching cells in nested sub-tables
    const tds = table.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (colIdx + 1) + ')');
    for (const td of tds) {
      td.style.width = newW + 'px';
      td.style.minWidth = newW + 'px';
      td.style.maxWidth = newW + 'px';
    }
    // For level-table columns, sync all level-tables with the same column code
    if (table.classList.contains('level-table') && th.dataset.code) {
      const code = th.dataset.code;
      document.querySelectorAll('.level-table th[data-code="' + code + '"]').forEach(function(otherTh) {
        if (otherTh === th) return;
        otherTh.style.width = newW + 'px';
        otherTh.style.minWidth = newW + 'px';
        otherTh.style.maxWidth = newW + 'px';
        const otherTable = otherTh.closest('table');
        const otherCi = Array.from(otherTh.parentElement.children).indexOf(otherTh);
        const otherTds = otherTable.querySelectorAll(':scope > tbody > tr > td:nth-child(' + (otherCi + 1) + ')');
        for (const td of otherTds) {
          td.style.width = newW + 'px';
          td.style.minWidth = newW + 'px';
          td.style.maxWidth = newW + 'px';
        }
      });
    }
  }
  document.addEventListener('mousedown', function(e) {
    const handle = e.target.closest('.col-resize');
    if (!handle) return;
    e.preventDefault();
    e.stopPropagation();
    th = handle.parentElement;
    colIdx = parseInt(handle.dataset.ci);
    resizing = true;
    startX = e.pageX;
    startW = th.getBoundingClientRect().width;
    document.body.classList.add('resizing');
  });
  document.addEventListener('mousemove', function(e) {
    if (!resizing) return;
    e.preventDefault();
    const newW = Math.max(10, startW + (e.pageX - startX));
    applyColWidth(newW);
  });
  document.addEventListener('mouseup', function() {
    if (!resizing) return;
    resizing = false; th = null; colIdx = -1;
    document.body.classList.remove('resizing');
  });
})();
</script>
</body>
</html>
